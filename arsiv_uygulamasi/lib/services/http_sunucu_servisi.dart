import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:crypto/crypto.dart';
import 'veritabani_servisi.dart';
import 'dosya_servisi.dart';
import 'belge_islemleri_servisi.dart';
import '../models/belge_modeli.dart';
import '../models/kategori_modeli.dart';
import '../models/kisi_modeli.dart';

class HttpSunucuServisi {
  static const int SUNUCU_PORTU = 8080;
  static const String UYGULAMA_KODU = 'arsivim';

  static HttpSunucuServisi? _instance;
  static HttpSunucuServisi get instance => _instance ??= HttpSunucuServisi._();
  HttpSunucuServisi._();

  final VeriTabaniServisi _veriTabani = VeriTabaniServisi();
  final DosyaServisi _dosyaServisi = DosyaServisi();

  HttpServer? _sunucu;
  String? _cihazId;
  String? _cihazAdi;
  String? _platform;
  bool _calisiyorMu = false;

  // Baƒülantƒ± callback'i
  Function(Map<String, dynamic>)? _onDeviceConnected;

  bool get calisiyorMu => _calisiyorMu;
  String? get cihazId => _cihazId;

  // Callback ayarlama metodu
  void setOnDeviceConnected(Function(Map<String, dynamic>) callback) {
    _onDeviceConnected = callback;
  }

  Future<void> sunucuyuBaslat() async {
    if (_calisiyorMu) {
      print('‚ö†Ô∏è Sunucu zaten √ßalƒ±≈üƒ±yor');
      return;
    }

    try {
      print('üîß HTTP Sunucusu ba≈ülatƒ±lƒ±yor...');

      // Cihaz bilgilerini al
      await _cihazBilgileriniAl();
      print('üì± Cihaz bilgileri alƒ±ndƒ±: $_cihazAdi ($_platform)');

      // Sunucuyu ba≈ülat
      print('üåê Port $SUNUCU_PORTU dinlenmeye ba≈ülanƒ±yor...');
      _sunucu = await HttpServer.bind(InternetAddress.anyIPv4, SUNUCU_PORTU);
      print(
        'üöÄ Ar≈üivim HTTP Sunucusu ba≈ülatƒ±ldƒ±: http://localhost:$SUNUCU_PORTU',
      );
      print('üì± Cihaz ID: $_cihazId');
      print('üíª Platform: $_platform');

      _calisiyorMu = true;
      print('‚úÖ Sunucu durumu: $_calisiyorMu');

      // ƒ∞stekleri dinle
      _sunucu!.listen((HttpRequest request) async {
        try {
          print('üì® HTTP ƒ∞stek: ${request.method} ${request.uri.path}');

          // CORS headers ekle (UTF-8 desteƒüi ile)
          request.response.headers.add('Access-Control-Allow-Origin', '*');
          request.response.headers.add(
            'Content-Type',
            'application/json; charset=utf-8',
          );

          String responseBody;
          int statusCode = 200;

          // Route handling
          bool isBinaryResponse = false;

          switch (request.uri.path) {
            case '/info':
              responseBody = await _handleInfo();
              break;
            case '/ping':
              responseBody = await _handlePing();
              break;
            case '/connect':
              responseBody = await _handleConnect(request);
              break;
            case '/documents':
              responseBody = await _handleDocuments();
              break;
            case '/categories':
              responseBody = await _handleCategories();
              break;
            case '/people':
              responseBody = await _handlePeople();
              break;
            default:
              if (request.uri.path.startsWith('/download/')) {
                responseBody = await _handleDownload(request);
                if (responseBody == 'BINARY_SENT') {
                  isBinaryResponse = true;
                  print('‚úÖ Binary dosya g√∂nderildi');
                }
              } else if (request.uri.path == '/upload' &&
                  request.method == 'POST') {
                responseBody = await _handleUpload(request);
                // Upload response'unda hata kontrol√º yap
                try {
                  final responseJson = json.decode(responseBody);
                  if (responseJson['status'] == 'error') {
                    statusCode = 400; // Bad Request
                  }
                } catch (e) {
                  // JSON parse edilemezse default 200 kullan
                }
              } else {
                statusCode = 404;
                responseBody = json.encode({'error': 'Endpoint bulunamadƒ±'});
              }
          }

          // Binary response deƒüilse normal JSON response g√∂nder
          if (!isBinaryResponse) {
            // UTF-8 bytes olarak yaz
            final responseBytes = utf8.encode(responseBody);
            request.response
              ..statusCode = statusCode
              ..add(responseBytes);

            await request.response.close();
            print('‚úÖ HTTP Yanƒ±t g√∂nderildi: $statusCode');
          }
        } catch (e) {
          print('‚ùå ƒ∞stek i≈üleme hatasƒ±: $e');
          try {
            final errorResponse = json.encode({
              'error': 'Sunucu hatasƒ±',
              'message': e.toString(),
            });
            final errorBytes = utf8.encode(errorResponse);

            request.response
              ..statusCode = 500
              ..add(errorBytes);
            await request.response.close();
          } catch (closeError) {
            print('‚ùå Response kapatma hatasƒ±: $closeError');
          }
        }
      });
    } catch (e) {
      print('‚ùå Sunucu ba≈ülatma hatasƒ±: $e');
      throw Exception('HTTP sunucusu ba≈ülatƒ±lamadƒ±: $e');
    }
  }

  Future<void> sunucuyuDurdur() async {
    if (_sunucu != null) {
      await _sunucu!.close();
      _sunucu = null;
      _calisiyorMu = false;
      print('üõë Ar≈üivim HTTP Sunucusu durduruldu');
    }
  }

  Future<void> _cihazBilgileriniAl() async {
    final deviceInfo = DeviceInfoPlugin();

    try {
      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        _cihazAdi = '${androidInfo.brand} ${androidInfo.model}';
        _platform = 'Android ${androidInfo.version.release}';
        _cihazId = androidInfo.id;
      } else if (Platform.isWindows) {
        final windowsInfo = await deviceInfo.windowsInfo;
        _cihazAdi = windowsInfo.computerName;
        _platform = 'Windows';
        _cihazId = windowsInfo.deviceId;
      } else if (Platform.isLinux) {
        final linuxInfo = await deviceInfo.linuxInfo;
        _cihazAdi = linuxInfo.name;
        _platform = 'Linux';
        _cihazId =
            linuxInfo.machineId ??
            'linux-${DateTime.now().millisecondsSinceEpoch}';
      } else if (Platform.isMacOS) {
        final macInfo = await deviceInfo.macOsInfo;
        _cihazAdi = macInfo.computerName;
        _platform = 'macOS';
        _cihazId =
            macInfo.systemGUID ??
            'mac-${DateTime.now().millisecondsSinceEpoch}';
      } else {
        _cihazAdi = 'Bilinmeyen Cihaz';
        _platform = Platform.operatingSystem;
        _cihazId = 'unknown-${DateTime.now().millisecondsSinceEpoch}';
      }

      // Cihaz ID'sini hash'le (g√ºvenlik i√ßin)
      final bytes = utf8.encode(_cihazId!);
      final digest = sha256.convert(bytes);
      _cihazId = digest.toString().substring(0, 16);
    } catch (e) {
      print('‚ö†Ô∏è Cihaz bilgisi alƒ±namadƒ±: $e');
      _cihazAdi = 'Ar≈üivim Cihazƒ±';
      _platform = Platform.operatingSystem;
      _cihazId = 'fallback-${DateTime.now().millisecondsSinceEpoch}';
    }
  }

  // HTTP Handler metodlarƒ±
  Future<String> _handleInfo() async {
    try {
      final belgeSayisi = await _veriTabani.toplamBelgeSayisi();
      final toplamBoyut = await _veriTabani.toplamDosyaBoyutu();

      return json.encode({
        'app': UYGULAMA_KODU,
        'version': '1.0.0',
        'id': _cihazId,
        'ad': _cihazAdi,
        'platform': _platform,
        'belgeSayisi': belgeSayisi,
        'toplamBoyut': toplamBoyut,
        'zaman': DateTime.now().toIso8601String(),
        'aktif': true,
      });
    } catch (e) {
      print('‚ùå Info endpoint hatasƒ±: $e');
      return json.encode({
        'app': UYGULAMA_KODU,
        'version': '1.0.0',
        'id': _cihazId,
        'ad': _cihazAdi,
        'platform': _platform,
        'belgeSayisi': 0,
        'toplamBoyut': 0,
        'zaman': DateTime.now().toIso8601String(),
        'aktif': true,
      });
    }
  }

  Future<String> _handlePing() async {
    return json.encode({
      'status': 'ok',
      'timestamp': DateTime.now().toIso8601String(),
      'cihaz': _cihazId,
    });
  }

  Future<String> _handleConnect(HttpRequest request) async {
    try {
      print('üîó Yeni baƒülantƒ± isteƒüi alƒ±ndƒ±');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final clientId = data['clientId'] as String?;
      final clientName = data['clientName'] as String?;

      if (clientId == null || clientName == null) {
        return json.encode({'error': 'clientId ve clientName gerekli'});
      }

      // Basit token olu≈ütur
      final token = 'token_${DateTime.now().millisecondsSinceEpoch}';

      // Baƒülantƒ± ba≈üarƒ±lƒ± bildirimi
      print('üéâ BAƒûLANTI BA≈ûARILI! Mobil cihaz baƒülandƒ±');
      print('üì± Baƒülanan cihaz: $clientName ($clientId)');
      print('üì± IP: ${request.connectionInfo?.remoteAddress?.address}');

      // UI'ya bildirim g√∂nder - HEMEN
      final deviceInfo = {
        'clientId': clientId,
        'clientName': clientName,
        'ip': request.connectionInfo?.remoteAddress?.address ?? 'bilinmiyor',
        'timestamp': DateTime.now().toIso8601String(),
        'platform': data['platform'] ?? 'Mobil',
        'belgeSayisi': data['belgeSayisi'] ?? 0,
        'toplamBoyut': data['toplamBoyut'] ?? 0,
      };

      // Callback'i √ßaƒüƒ±r
      if (_onDeviceConnected != null) {
        print('üì¢ Callback √ßaƒürƒ±lƒ±yor...');
        Future.microtask(() => _onDeviceConnected!(deviceInfo));
      } else {
        print('‚ö†Ô∏è Callback tanƒ±mlanmamƒ±≈ü!');
      }

      return json.encode({
        'success': true,
        'token': token,
        'serverId': _cihazId,
        'serverName': _cihazAdi,
        'message': 'Baƒülantƒ± kuruldu',
        'serverInfo': {
          'platform': _platform,
          'belgeSayisi': await _veriTabani.toplamBelgeSayisi(),
          'toplamBoyut': await _veriTabani.toplamDosyaBoyutu(),
        },
      });
    } catch (e) {
      print('‚ùå Connect handler hatasƒ±: $e');
      return json.encode({'error': 'Baƒülantƒ± hatasƒ±', 'message': e.toString()});
    }
  }

  // Belge listesi endpoint'i
  Future<String> _handleDocuments() async {
    try {
      print('üìÑ Belge listesi istendi');
      final belgeler = await _veriTabani.belgeleriGetir();

      final belgeListesi =
          belgeler
              .map(
                (belge) => {
                  'id': belge.id,
                  'dosyaAdi': belge.dosyaAdi,
                  'dosyaBoyutu': belge.dosyaBoyutu,
                  'olusturmaTarihi': belge.olusturmaTarihi.toIso8601String(),
                  'kategoriId': belge.kategoriId,
                  'baslik': belge.baslik,
                  'aciklama': belge.aciklama,
                  'kisiId': belge.kisiId,
                  'etiketler': belge.etiketler,
                },
              )
              .toList();

      return json.encode({
        'status': 'success',
        'documents': belgeListesi,
        'count': belgeListesi.length,
      });
    } catch (e) {
      print('‚ùå Documents endpoint hatasƒ±: $e');
      return json.encode({
        'status': 'error',
        'message': 'Belgeler alƒ±namadƒ±: $e',
      });
    }
  }

  // Belge indirme endpoint'i
  Future<String> _handleDownload(HttpRequest request) async {
    try {
      // URL decode'u g√ºvenli ≈üekilde yap
      String dosyaAdi;
      try {
        dosyaAdi = Uri.decodeComponent(request.uri.pathSegments.last);
      } catch (e) {
        // Decode edilemiyorsa raw string kullan
        dosyaAdi = request.uri.pathSegments.last;
        print('‚ö†Ô∏è URL decode hatasƒ±, raw string kullanƒ±lƒ±yor: $e');
      }
      print('üì• Belge indirme isteƒüi: $dosyaAdi');

      // Dosya adƒ± ile belge ara (esnek arama)
      List<BelgeModeli> belgeler = await _veriTabani.belgeAra(dosyaAdi);

      // Eƒüer bulunamazsa, URL decode edilmi≈ü hali ile de dene
      if (belgeler.isEmpty) {
        print('üìã ƒ∞lk arama sonu√ßsuz, farklƒ± encode t√ºrleri deneniyor...');

        // Farklƒ± encode varyasyonlarƒ±nƒ± dene
        final aramaTerimleri = [
          dosyaAdi,
          Uri.encodeComponent(dosyaAdi),
          dosyaAdi.replaceAll('%20', ' '),
          dosyaAdi.replaceAll('+', ' '),
        ];

        for (final terim in aramaTerimleri) {
          belgeler = await _veriTabani.belgeAra(terim);
          if (belgeler.isNotEmpty) {
            print('‚úÖ Belge bulundu: $terim');
            break;
          }
        }

        if (belgeler.isEmpty) {
          print('‚ùå Belge hi√ßbir encode t√ºr√ºnde bulunamadƒ±: $dosyaAdi');
          request.response.statusCode = 404;
          await request.response.close();
          return json.encode({'error': 'Belge bulunamadƒ±'});
        }
      }

      final dosya = File(belgeler.first.dosyaYolu);
      if (!await dosya.exists()) {
        request.response.statusCode = 404;
        await request.response.close();
        return json.encode({'error': 'Dosya bulunamadƒ±'});
      }

      final dosyaBytes = await dosya.readAsBytes();

      // T√ºrk√ße karakterler i√ßin g√ºvenli filename olu≈ütur
      final safeDosyaAdi = dosyaAdi.replaceAll(RegExp(r'[^\w\-_\.]'), '_');

      request.response
        ..headers.contentType = ContentType.binary
        ..headers.contentLength = dosyaBytes.length
        ..headers.add(
          'Content-Disposition',
          'attachment; filename=$safeDosyaAdi',
        )
        ..headers.add('Access-Control-Allow-Origin', '*')
        ..headers.add('Access-Control-Expose-Headers', 'Content-Disposition');

      // Dosya verilerini yaz ve response'u kapat
      request.response.add(dosyaBytes);
      await request.response.close();

      print('‚úÖ Belge g√∂nderildi: $dosyaAdi (${dosyaBytes.length} bytes)');
      print('‚úÖ Binary dosya g√∂nderildi');
      return 'BINARY_SENT'; // Binary response g√∂nderildi i≈üareti
    } catch (e) {
      print('‚ùå Download endpoint hatasƒ±: $e');

      // Response kapatmayƒ± dene, eƒüer zaten kapalƒ±ysa ignore et
      try {
        request.response.statusCode = 500;
        await request.response.close();
        print('‚ö†Ô∏è Error response g√∂nderildi');
      } catch (closeError) {
        print('‚ö†Ô∏è Response zaten kapatƒ±lmƒ±≈ü veya kapatma hatasƒ±: $closeError');
      }

      return json.encode({'error': 'ƒ∞ndirme hatasƒ±: $e'});
    }
  }

  // Kategori listesi endpoint'i
  Future<String> _handleCategories() async {
    try {
      print('üìÇ Kategori listesi istendi');
      final kategoriler = await _veriTabani.kategorileriGetir();

      final kategoriListesi =
          kategoriler
              .map(
                (kategori) => {
                  'id': kategori.id,
                  'ad': kategori.kategoriAdi,
                  'renkKodu': kategori.renkKodu,
                  'simgeKodu': kategori.simgeKodu,
                  'aciklama': kategori.aciklama,
                  'olusturmaTarihi': kategori.olusturmaTarihi.toIso8601String(),
                  'aktif': kategori.aktif,
                  'belgeSayisi': kategori.belgeSayisi,
                },
              )
              .toList();

      return json.encode({
        'status': 'success',
        'categories': kategoriListesi,
        'count': kategoriListesi.length,
      });
    } catch (e) {
      print('‚ùå Categories endpoint hatasƒ±: $e');
      return json.encode({
        'status': 'error',
        'message': 'Kategoriler alƒ±namadƒ±: $e',
      });
    }
  }

  // Ki≈üi listesi endpoint'i
  Future<String> _handlePeople() async {
    try {
      print('üßë‚Äçü§ù‚Äçüßë Ki≈üi listesi istendi');
      final kisiler = await _veriTabani.kisileriGetir();

      final kisiListesi =
          kisiler
              .map(
                (kisi) => {
                  'id': kisi.id,
                  'ad': kisi.ad,
                  'soyad': kisi.soyad,
                  'tamAd': kisi.tamAd,
                  'olusturmaTarihi': kisi.olusturmaTarihi.toIso8601String(),
                  'guncellemeTarihi': kisi.guncellemeTarihi.toIso8601String(),
                  'aktif': kisi.aktif,
                },
              )
              .toList();

      return json.encode({
        'status': 'success',
        'people': kisiListesi,
        'count': kisiListesi.length,
      });
    } catch (e) {
      print('‚ùå People endpoint hatasƒ±: $e');
      return json.encode({
        'status': 'error',
        'message': 'Ki≈üiler alƒ±namadƒ±: $e',
      });
    }
  }

  // Belge y√ºkleme endpoint'i - ƒ∞yile≈ütirilmi≈ü multipart parser
  Future<String> _handleUpload(HttpRequest request) async {
    try {
      print('üì§ Belge y√ºkleme isteƒüi alƒ±ndƒ±');

      // Multipart form data parser - Improved
      final boundary = request.headers.contentType?.parameters['boundary'];
      if (boundary == null) {
        throw Exception('Multipart boundary bulunamadƒ±');
      }

      print('üîß Boundary bulundu: $boundary');

      // T√ºm body'yi binary olarak oku
      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );

      print('üì¶ Body alƒ±ndƒ±: ${bodyBytes.length} bytes');

      // G√ºvenli multipart parsing
      final parsedParts = _parseMultipartData(bodyBytes, boundary);

      if (parsedParts.isEmpty) {
        throw Exception('Multipart veriler parse edilemedi');
      }

      print('üîç ${parsedParts.length} part ba≈üarƒ±yla parse edildi');

      String? metadata;
      List<int>? fileBytes;
      String? fileName;

      // Parse edilen partlarƒ± i≈üle
      for (final part in parsedParts) {
        final headers = part['headers'] as Map<String, String>;
        final data = part['data'] as List<int>;

        final contentDisposition = headers['content-disposition'] ?? '';

        if (contentDisposition.contains('name="metadata"')) {
          metadata = utf8.decode(data, allowMalformed: true);
          print(
            '‚úÖ Metadata alƒ±ndƒ±: ${metadata.substring(0, metadata.length.clamp(0, 100))}...',
          );
        } else if (contentDisposition.contains('name="file"')) {
          fileBytes = data;

          // Filename'i header'dan √ßƒ±kar
          final filenameMatch = RegExp(
            r'filename="([^"]*)"',
          ).firstMatch(contentDisposition);
          if (filenameMatch != null) {
            fileName = filenameMatch.group(1);
            print('‚úÖ Filename bulundu: $fileName');
          }

          print('‚úÖ File bytes alƒ±ndƒ±: ${fileBytes!.length} bytes');

          // Hash kontrol√º ile data integrity check
          if (fileBytes!.isNotEmpty) {
            final hash = sha256.convert(fileBytes!).toString();
            print('üîí Dosya hash: ${hash.substring(0, 16)}...');
          }
        }
      }

      // Debug bilgileri
      print('üîç Parsing sonu√ßlarƒ±:');
      print('   ‚Ä¢ Metadata: ${metadata != null ? "‚úÖ" : "‚ùå"}');
      print(
        '   ‚Ä¢ FileBytes: ${fileBytes != null ? "‚úÖ (${fileBytes?.length} bytes)" : "‚ùå"}',
      );
      print('   ‚Ä¢ FileName: ${fileName ?? "‚ùå"}');

      if (metadata == null || fileBytes == null || fileName == null) {
        final errorMsg =
            'Gerekli veriler eksik - metadata: $metadata, fileBytes: ${fileBytes?.length}, fileName: $fileName';
        print('‚ùå $errorMsg');
        throw Exception(errorMsg);
      }

      // Metadata'yi parse et
      Map<String, dynamic> metadataJson;
      try {
        metadataJson = json.decode(metadata) as Map<String, dynamic>;
        print(
          'üìã Metadata ba≈üarƒ±yla parse edildi: ${metadataJson['dosyaAdi']}',
        );
        print(
          '   ‚Ä¢ Ki≈üi: ${metadataJson['kisiAd']} ${metadataJson['kisiSoyad']}',
        );
        print('   ‚Ä¢ Kategori ID: ${metadataJson['kategoriId']}');
      } catch (e) {
        print('‚ùå Metadata parse hatasƒ±: $e');
        print('   Raw metadata: $metadata');
        throw Exception('Metadata parse edilemedi: $e');
      }

      // Dosyayƒ± belgeler klas√∂r√ºne kaydet
      final dosyaServisi = DosyaServisi();
      final belgelerKlasoru = await dosyaServisi.belgelerKlasoruYolu();
      final yeniDosyaYolu = '$belgelerKlasoru/$fileName';

      print('üíæ Dosya yazƒ±lƒ±yor: $yeniDosyaYolu (${fileBytes.length} bytes)');

      // Dosyayƒ± yaz
      final dosya = File(yeniDosyaYolu);
      try {
        await dosya.writeAsBytes(fileBytes);
        print('‚úÖ Dosya ba≈üarƒ±yla yazƒ±ldƒ±');

        // Dosya boyutunu kontrol et
        final writtenSize = await dosya.length();
        print('üìè Yazƒ±lan dosya boyutu: $writtenSize bytes');

        if (writtenSize != fileBytes.length) {
          throw Exception(
            'Dosya boyutu e≈üle≈ümiyor - beklenen: ${fileBytes.length}, yazƒ±lan: $writtenSize',
          );
        }
      } catch (e) {
        print('‚ùå Dosya yazma hatasƒ±: $e');
        throw Exception('Dosya yazƒ±lamadƒ±: $e');
      }

      // Ki≈üi ID'sini e≈üle≈ütir (ad-soyad kombinasyonuna g√∂re)
      int? eslestirilenKisiId;
      if (metadataJson['kisiAd'] != null && metadataJson['kisiSoyad'] != null) {
        try {
          // Yerel ki≈üi listesinde ad-soyad kombinasyonunu ara
          final yerelKisiler = await _veriTabani.kisileriGetir();
          final eslestirilenKisi = yerelKisiler.firstWhere(
            (k) =>
                k.ad == metadataJson['kisiAd'] &&
                k.soyad == metadataJson['kisiSoyad'],
            orElse:
                () => KisiModeli(
                  ad: '',
                  soyad: '',
                  olusturmaTarihi: DateTime.now(),
                  guncellemeTarihi: DateTime.now(),
                ),
          );

          if (eslestirilenKisi.ad.isNotEmpty) {
            eslestirilenKisiId = eslestirilenKisi.id;
            print('üë§ Ki≈üi e≈üle≈ütirildi: ${eslestirilenKisi.tamAd}');
          } else {
            // Ki≈üi yoksa yeni ki≈üi ekle
            final yeniKisi = KisiModeli(
              ad: metadataJson['kisiAd'],
              soyad: metadataJson['kisiSoyad'],
              olusturmaTarihi: DateTime.now(),
              guncellemeTarihi: DateTime.now(),
            );

            final kisiId = await _veriTabani.kisiEkle(yeniKisi);
            eslestirilenKisiId = kisiId;
            print('üë§ Yeni ki≈üi eklendi: ${yeniKisi.tamAd}');
          }
        } catch (e) {
          print('‚ö†Ô∏è Ki≈üi e≈üle≈ütirme hatasƒ±: $e');
          // Varsayƒ±lan olarak ilk ki≈üiyi se√ß
          final yerelKisiler = await _veriTabani.kisileriGetir();
          if (yerelKisiler.isNotEmpty) {
            eslestirilenKisiId = yerelKisiler.first.id;
            print('‚ö†Ô∏è Varsayƒ±lan ki≈üi se√ßildi: ${yerelKisiler.first.tamAd}');
          }
        }
      } else if (metadataJson['kisiId'] != null) {
        // Fallback: eski y√∂ntem (ID ile)
        try {
          final yerelKisiler = await _veriTabani.kisileriGetir();
          final eslestirilenKisi = yerelKisiler.firstWhere(
            (k) => k.id == metadataJson['kisiId'],
            orElse:
                () => KisiModeli(
                  ad: '',
                  soyad: '',
                  olusturmaTarihi: DateTime.now(),
                  guncellemeTarihi: DateTime.now(),
                ),
          );

          if (eslestirilenKisi.ad.isNotEmpty) {
            eslestirilenKisiId = eslestirilenKisi.id;
          } else if (yerelKisiler.isNotEmpty) {
            eslestirilenKisiId = yerelKisiler.first.id;
            print(
              '‚ö†Ô∏è ID ile e≈üle≈ütirilemedi, varsayƒ±lan se√ßildi: ${yerelKisiler.first.tamAd}',
            );
          }
        } catch (e) {
          print('‚ö†Ô∏è Ki≈üi ID e≈üle≈ütirme hatasƒ±: $e');
        }
      }

      // Dosya hash'ini hesapla
      final dosyaHashBytes = sha256.convert(fileBytes);
      final dosyaHashString = dosyaHashBytes.toString();
      print('üîê Dosya hash hesaplandƒ±: ${dosyaHashString.substring(0, 16)}...');

      // Duplicate kontrol√º yap
      try {
        final mevcutBelgeler = await _veriTabani.belgeleriGetir();
        final duplicateBelge = mevcutBelgeler.firstWhere(
          (belge) => belge.dosyaHash == dosyaHashString,
          orElse:
              () => BelgeModeli(
                dosyaAdi: '',
                orijinalDosyaAdi: '',
                dosyaYolu: '',
                dosyaBoyutu: 0,
                dosyaTipi: '',
                dosyaHash: '',
                olusturmaTarihi: DateTime.now(),
                guncellemeTarihi: DateTime.now(),
                kategoriId: 1,
                baslik: '',
                aciklama: '',
              ),
        );

        if (duplicateBelge.dosyaAdi.isNotEmpty) {
          print('‚ö†Ô∏è Duplicate dosya bulundu: ${duplicateBelge.dosyaAdi}');

          // Dosyayƒ± disk'ten sil
          final dosya = File(yeniDosyaYolu);
          if (await dosya.exists()) {
            await dosya.delete();
            print('üóëÔ∏è Duplicate dosya diskten silindi');
          }

          return json.encode({
            'status': 'warning',
            'message': 'Bu dosya zaten mevcut',
            'fileName': fileName,
            'existingFile': duplicateBelge.dosyaAdi,
            'duplicate': true,
          });
        }
      } catch (e) {
        print('‚ö†Ô∏è Duplicate kontrol√º hatasƒ±: $e');
        // Hata durumunda devam et
      }

      // Veritabanƒ±na ekle
      final yeniBelge = BelgeModeli(
        dosyaAdi: fileName,
        orijinalDosyaAdi: metadataJson['dosyaAdi'] ?? fileName,
        dosyaYolu: yeniDosyaYolu,
        dosyaBoyutu: fileBytes.length,
        dosyaTipi: fileName.split('.').last.toLowerCase(),
        dosyaHash: dosyaHashString,
        olusturmaTarihi: DateTime.parse(metadataJson['olusturmaTarihi']),
        guncellemeTarihi: DateTime.now(),
        kategoriId: metadataJson['kategoriId'] ?? 1,
        baslik: metadataJson['baslik'],
        aciklama: metadataJson['aciklama'],
        kisiId: eslestirilenKisiId,
        etiketler:
            metadataJson['etiketler'] != null
                ? List<String>.from(metadataJson['etiketler'])
                : null,
      );

      final belgeId = await _veriTabani.belgeEkle(yeniBelge);
      print('‚úÖ Belge veritabanƒ±na eklendi - ID: $belgeId');

      print('üéâ Belge ba≈üarƒ±yla y√ºklendi: $fileName');
      print('üìä √ñzet:');
      print('   ‚Ä¢ Dosya adƒ±: $fileName');
      print('   ‚Ä¢ Boyut: ${fileBytes.length} bytes');
      print(
        '   ‚Ä¢ Ki≈üi: ${metadataJson['kisiAd']} ${metadataJson['kisiSoyad']}',
      );
      print('   ‚Ä¢ Kategori ID: ${metadataJson['kategoriId']}');

      return json.encode({
        'status': 'success',
        'message': 'Belge ba≈üarƒ±yla y√ºklendi',
        'fileName': fileName,
        'size': fileBytes.length,
        'belgeId': belgeId,
        'kisi': '${metadataJson['kisiAd']} ${metadataJson['kisiSoyad']}',
      });
    } catch (e, stackTrace) {
      print('‚ùå Upload endpoint hatasƒ±: $e');
      print('üìã Stack trace: $stackTrace');

      // Hata durumunda da uygun response d√∂n
      final errorResponse = json.encode({
        'status': 'error',
        'error': 'Y√ºkleme hatasƒ±',
        'message': e.toString(),
        'timestamp': DateTime.now().toIso8601String(),
      });

      // Status code'u d√ºzg√ºn ayarla ama response'u bizim d√∂nd√ºrmemize izin ver
      // √á√ºnk√º main handler zaten response'u kapatacak
      return errorResponse;
    }
  }

  // Multipart parsing helper fonksiyonlarƒ±
  List<Map<String, dynamic>> _parseMultipartData(
    List<int> bodyBytes,
    String boundary,
  ) {
    final parts = <Map<String, dynamic>>[];

    try {
      // Boundary bytes'ƒ±nƒ± hazƒ±rla
      final boundaryBytes = utf8.encode('--$boundary');
      final endBoundaryBytes = utf8.encode('--$boundary--');

      int start = 0;
      int partIndex = 0;

      // ƒ∞lk boundary'i atla
      int firstBoundaryIndex = _findBoundary(bodyBytes, boundaryBytes, start);
      if (firstBoundaryIndex == -1) {
        print('‚ùå ƒ∞lk boundary bulunamadƒ±');
        return parts;
      }

      start = firstBoundaryIndex + boundaryBytes.length;
      // \r\n'i atla
      if (start < bodyBytes.length && bodyBytes[start] == 13) start++;
      if (start < bodyBytes.length && bodyBytes[start] == 10) start++;

      // Her part'ƒ± i≈üle
      while (start < bodyBytes.length && partIndex < 10) {
        // Bir sonraki boundary'i bul
        int nextBoundaryIndex = _findBoundary(bodyBytes, boundaryBytes, start);
        int endBoundaryIndex = _findBoundary(
          bodyBytes,
          endBoundaryBytes,
          start,
        );

        // En yakƒ±n boundary'i se√ß
        int currentPartEnd = -1;
        if (nextBoundaryIndex != -1 && endBoundaryIndex != -1) {
          currentPartEnd =
              nextBoundaryIndex < endBoundaryIndex
                  ? nextBoundaryIndex
                  : endBoundaryIndex;
        } else if (nextBoundaryIndex != -1) {
          currentPartEnd = nextBoundaryIndex;
        } else if (endBoundaryIndex != -1) {
          currentPartEnd = endBoundaryIndex;
        }

        if (currentPartEnd == -1) break;

        // Part data'sƒ±nƒ± al
        final partData = bodyBytes.sublist(start, currentPartEnd);
        if (partData.isEmpty) break;

        // Header'ƒ± bul
        final headerEndIndex = _findHeaderEnd(partData);
        if (headerEndIndex == -1) {
          print('‚ö†Ô∏è Part $partIndex: Header end bulunamadƒ±');
          break;
        }

        // Header'ƒ± parse et
        final headerBytes = partData.sublist(0, headerEndIndex);
        final headerString = utf8.decode(headerBytes, allowMalformed: true);

        // Header'larƒ± ayrƒ±≈ütƒ±r
        final headers = <String, String>{};
        final headerLines = headerString.split('\r\n');

        for (final line in headerLines) {
          if (line.contains(':')) {
            final parts = line.split(':');
            if (parts.length >= 2) {
              final key = parts[0].trim().toLowerCase();
              final value = parts.sublist(1).join(':').trim();
              headers[key] = value;
            }
          }
        }

        // Data kƒ±smƒ±nƒ± al
        final dataStart = headerEndIndex + 4; // \r\n\r\n atla
        List<int> data = [];

        if (dataStart < partData.length) {
          data = partData.sublist(dataStart);

          // Trailing \r\n'leri temizle
          while (data.isNotEmpty && (data.last == 13 || data.last == 10)) {
            data.removeLast();
          }
        }

        // Part'ƒ± ekle
        parts.add({'headers': headers, 'data': data});

        print('‚úÖ Part $partIndex parse edildi: ${data.length} bytes');
        partIndex++;

        // Sonraki part'a ge√ß
        start = currentPartEnd + boundaryBytes.length;
        if (start < bodyBytes.length && bodyBytes[start] == 13) start++;
        if (start < bodyBytes.length && bodyBytes[start] == 10) start++;

        // End boundary'e ula≈ütƒ±ysak dur
        if (currentPartEnd == endBoundaryIndex) break;
      }

      print('üéâ Toplam ${parts.length} part ba≈üarƒ±yla parse edildi');
      return parts;
    } catch (e) {
      print('‚ùå Multipart parsing hatasƒ±: $e');
      return parts;
    }
  }

  int _findHeaderEnd(List<int> bytes) {
    // \r\n\r\n (double CRLF) pattern'ini ara
    final pattern = [13, 10, 13, 10]; // \r\n\r\n

    for (int i = 0; i <= bytes.length - pattern.length; i++) {
      bool match = true;
      for (int j = 0; j < pattern.length; j++) {
        if (bytes[i + j] != pattern[j]) {
          match = false;
          break;
        }
      }
      if (match) {
        return i;
      }
    }
    return -1;
  }

  int _findBoundary(List<int> haystack, List<int> needle, int start) {
    for (int i = start; i <= haystack.length - needle.length; i++) {
      bool match = true;
      for (int j = 0; j < needle.length; j++) {
        if (haystack[i + j] != needle[j]) {
          match = false;
          break;
        }
      }
      if (match) {
        return i;
      }
    }
    return -1;
  }

  // Kategori senkronizasyon endpoint'i (basitle≈ütirilmi≈ü)
  Future<String> _handleCategorySync(HttpRequest request) async {
    try {
      print('üìÇ Kategori senkronizasyon endpoint\'i √ßaƒürƒ±ldƒ±');

      return json.encode({
        'status': 'success',
        'message': 'Kategori sync endpoint\'i hazƒ±r (implement edilecek)',
      });
    } catch (e) {
      print('‚ùå Category sync hatasƒ±: $e');
      request.response.statusCode = 500;
      return json.encode({'error': 'Kategori sync hatasƒ±: $e'});
    }
  }

  // Ki≈üi senkronizasyon endpoint'i (basitle≈ütirilmi≈ü)
  Future<String> _handlePeopleSync(HttpRequest request) async {
    try {
      print('üßë‚Äçü§ù‚Äçüßë Ki≈üi senkronizasyon endpoint\'i √ßaƒürƒ±ldƒ±');

      return json.encode({
        'status': 'success',
        'message': 'Ki≈üi sync endpoint\'i hazƒ±r (implement edilecek)',
      });
    } catch (e) {
      print('‚ùå People sync hatasƒ±: $e');
      request.response.statusCode = 500;
      return json.encode({'error': 'Ki≈üi sync hatasƒ±: $e'});
    }
  }
}
