import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:crypto/crypto.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'veritabani_servisi.dart';
import 'dosya_servisi.dart';
import '../models/belge_modeli.dart';
import '../models/kisi_modeli.dart';
import '../models/kategori_modeli.dart';

class HttpSunucuServisi {
  static const int SUNUCU_PORTU = 8080;
  static const String UYGULAMA_KODU = 'arsivim';

  // Timeout ayarlarƒ±
  static const Duration REQUEST_TIMEOUT = Duration(seconds: 30);
  static const Duration CONNECTION_TIMEOUT = Duration(minutes: 5);
  static const Duration KEEPALIVE_TIMEOUT = Duration(minutes: 2);

  // Dosya boyutu limitleri (g√ºncellenmi≈ü)
  static const int MAX_FILE_SIZE_MOBILE = 10 * 1024 * 1024; // 10MB
  static const int MAX_FILE_SIZE_DESKTOP = 50 * 1024 * 1024; // 50MB
  static const int MAX_PROFILE_PHOTO_SIZE = 5 * 1024 * 1024; // 5MB
  static const int BATCH_SIZE = 10; // Batch processing boyutu

  static HttpSunucuServisi? _instance;
  static HttpSunucuServisi get instance => _instance ??= HttpSunucuServisi._();
  HttpSunucuServisi._();

  final VeriTabaniServisi _veriTabani = VeriTabaniServisi();
  final DosyaServisi _dosyaServisi = DosyaServisi();

  HttpServer? _sunucu;
  String? _cihazId;
  String? _cihazAdi;
  String? _platform;
  bool _calisiyorMu = false;
  Timer? _cleanupTimer;

  // Manuel IP override √∂zelliƒüi
  String? _manuelIP;

  // Callback fonksiyonlarƒ±
  Function(String)? onConnectionReceived;
  Function(String)? onDeviceConnected;
  Function(String, Map<String, dynamic>)? onDeviceDisconnected;
  Function(Map<String, dynamic>)? _onQRLoginRequest;

  bool get calisiyorMu => _calisiyorMu;
  String? get cihazId => _cihazId;
  String? get cihazAdi => _cihazAdi;
  String? get platform => _platform;
  int get port => SUNUCU_PORTU;

  // Manuel IP ayarlama
  void setManuelIP(String? ip) {
    _manuelIP = ip;
    print('üîß Manuel IP ayarlandƒ±: $ip');
  }

  String? get manuelIP => _manuelIP;

  // QR Login callback ayarlama
  void setOnQRLoginRequest(Function(Map<String, dynamic>) callback) {
    _onQRLoginRequest = callback;
    print('üì± QR Login callback ayarlandƒ±');
  }

  // Baglanti callback'leri
  Function(Map<String, dynamic>)? _onDeviceConnected;
  Function(Map<String, dynamic>)? _onDeviceDisconnected;

  // Bagli cihazlar listesi
  final List<Map<String, dynamic>> _bagliCihazlar = [];

  List<Map<String, dynamic>> get bagliCihazlar =>
      List.unmodifiable(_bagliCihazlar);

  // Callback'leri ayarla
  void baglantiCallbackleri({
    Function(Map<String, dynamic>)? onDeviceConnected,
    Function(String, Map<String, dynamic>)? onDeviceDisconnected,
  }) {
    _onDeviceConnected = onDeviceConnected;
    // Disconnection callback'ini wrap ediyoruz
    if (onDeviceDisconnected != null) {
      _onDeviceDisconnected = (deviceInfo) {
        final deviceId = deviceInfo['device_id'] as String? ?? 'unknown';
        onDeviceDisconnected(deviceId, deviceInfo);
      };
    }
    print('üì° HTTP sunucu callback\'leri ayarlandƒ±');
  }

  // Callback ayarlama metodlari
  void setOnDeviceConnected(Function(Map<String, dynamic>) callback) {
    _onDeviceConnected = callback;
  }

  void setOnDeviceDisconnected(Function(Map<String, dynamic>) callback) {
    _onDeviceDisconnected = callback;
  }

  Future<void> sunucuyuBaslat() async {
    if (_calisiyorMu) {
      print('‚ö†Ô∏è Sunucu zaten √ßalƒ±≈üƒ±yor');
      return;
    }

    try {
      print('üöÄ HTTP Sunucusu ba≈ülatƒ±lƒ±yor...');

      // Cihaz bilgilerini al
      await _cihazBilgileriniAl();
      print('‚úÖ Cihaz bilgileri alƒ±ndƒ±: $_cihazAdi ($_platform)');

      // Sunucuyu ba≈ülat
      print('üîå Port $SUNUCU_PORTU dinlenmeye ba≈ülanƒ±yor...');
      _sunucu = await HttpServer.bind(InternetAddress.anyIPv4, SUNUCU_PORTU);

      // Sunucu timeout ayarlarƒ±
      _sunucu!.idleTimeout = KEEPALIVE_TIMEOUT;

      print(
        '‚úÖ Arsivim HTTP Sunucusu ba≈ülatƒ±ldƒ±: http://localhost:$SUNUCU_PORTU',
      );

      // IP adresi alƒ±ndƒ±
      final realIP = await getRealIPAddress();
      print('üåê Ger√ßek IP adresi: $realIP');

      print('üÜî Cihaz ID: $_cihazId');
      print('üíª Platform: $_platform');

      _calisiyorMu = true;
      print('‚úÖ Sunucu durumu: $_calisiyorMu');

      // Cleanup timer ba≈ülat
      _startCleanupTimer();

      // ƒ∞stekleri dinle
      _sunucu!.listen((HttpRequest request) async {
        try {
          print('üì® HTTP ƒ∞stek: ${request.method} ${request.uri.path}');

          // Request timeout kontrol√º (HttpServer kendi timeout y√∂netimi yapƒ±yor)

          // CORS headers ekle
          _addCORSHeaders(request.response);

          // OPTIONS request i√ßin CORS preflight
          if (request.method == 'OPTIONS') {
            request.response.statusCode = 200;
            await request.response.close();
            return;
          }

          String responseBody;
          int statusCode = 200;

          // Route handling - T√ºm endpoint'ler eklendi
          switch (request.uri.path) {
            case '/ping':
              responseBody = await _handlePing();
              break;
            case '/info':
              responseBody = await _handleInfo();
              break;
            case '/connect':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleConnect,
              );
              break;
            case '/disconnect':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleDisconnect,
              );
              break;
            case '/status':
              responseBody = await _handleStatus();
              break;
            case '/devices':
              responseBody = await _handleDevices();
              break;
            case '/device-connected':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleDeviceConnected,
              );
              break;
            case '/device-disconnected':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleDeviceDisconnected,
              );
              break;
            // Senkronizasyon endpoint'leri
            case '/sync/belgeler':
              if (request.method == 'GET') {
                responseBody = await _handleSyncBelgeler();
              } else if (request.method == 'POST') {
                responseBody = await _handleReceiveBelgeler(request);
              } else {
                statusCode = 405;
                responseBody = _createErrorResponse(
                  'Method not allowed',
                  'Only GET and POST methods are supported',
                );
              }
              break;
            case '/sync/belgeler-kapsamli':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleReceiveBelgelerKapsamli,
              );
              break;
            case '/sync/kisiler':
              if (request.method == 'GET') {
                responseBody = await _handleSyncKisiler();
              } else if (request.method == 'POST') {
                responseBody = await _handleReceiveKisiler(request);
              } else {
                statusCode = 405;
                responseBody = _createErrorResponse(
                  'Method not allowed',
                  'Only GET and POST methods are supported',
                );
              }
              break;
            case '/sync/receive_kisiler':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleReceiveKisiler,
              );
              break;
            case '/sync/kategoriler':
              if (request.method == 'GET') {
                responseBody = await _handleSyncKategoriler();
              } else if (request.method == 'POST') {
                responseBody = await _handleReceiveKategoriler(request);
              } else {
                statusCode = 405;
                responseBody = _createErrorResponse(
                  'Method not allowed',
                  'Only GET and POST methods are supported',
                );
              }
              break;
            case '/sync/receive_kategoriler':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleReceiveKategoriler,
              );
              break;
            case '/sync/bekleyen':
              responseBody = await _handleBekleyenSenkronlar();
              break;
            case '/sync/status':
              responseBody = await _handleSyncStatus();
              break;
            case '/auth/qr-login':
              responseBody = await _handleMethodValidation(
                request,
                'POST',
                _handleQRLogin,
              );
              break;
            default:
              statusCode = 404;
              responseBody = _createErrorResponse(
                'Endpoint bulunamadƒ±',
                'Belirtilen endpoint mevcut deƒüil: ${request.uri.path}',
              );
          }

          // Response g√∂nder
          await _sendResponse(request.response, responseBody, statusCode);
          print('‚úÖ HTTP Yanƒ±t g√∂nderildi: $statusCode');
        } catch (e, stackTrace) {
          print('‚ùå ƒ∞stek i≈üleme hatasƒ±: $e');
          print('üìç Stack trace: $stackTrace');
          await _sendErrorResponse(
            request.response,
            'Sunucu hatasƒ±',
            e.toString(),
          );
        }
      });
    } catch (e, stackTrace) {
      print('‚ùå Sunucu ba≈ülatma hatasƒ±: $e');
      print('üìç Stack trace: $stackTrace');
      throw Exception('HTTP sunucusu ba≈ülatƒ±lamadƒ±: $e');
    }
  }

  Future<void> sunucuyuDurdur() async {
    try {
      print('üõë HTTP Sunucusu durduruluyor...');

      // Cleanup timer'ƒ± durdur
      _cleanupTimer?.cancel();
      _cleanupTimer = null;

      // Sunucuyu durdur
      final sunucu = _sunucu;
      if (sunucu != null) {
        await sunucu.close(force: true);
        _sunucu = null;
      }

      _calisiyorMu = false;
      _bagliCihazlar.clear();

      print('‚úÖ Arsivim HTTP Sunucusu durduruldu');
    } catch (e) {
      print('‚ùå Sunucu durdurma hatasƒ±: $e');
    }
  }

  // Cleanup timer ba≈ülat
  void _startCleanupTimer() {
    _cleanupTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _cleanupConnections();
    });
  }

  // Baƒülantƒ± temizleme
  void _cleanupConnections() {
    try {
      final now = DateTime.now();
      final removedDevices = <Map<String, dynamic>>[];

      _bagliCihazlar.removeWhere((device) {
        final lastSeenStr = device['last_seen'] as String?;
        if (lastSeenStr == null) return true;

        final lastSeen = DateTime.tryParse(lastSeenStr);
        if (lastSeen == null) return true;

        final isTimedOut = now.difference(lastSeen) > CONNECTION_TIMEOUT;
        if (isTimedOut) {
          removedDevices.add(device);
        }
        return isTimedOut;
      });

      // Timeout olan cihazlar i√ßin bildirim g√∂nder
      for (final device in removedDevices) {
        print('‚è∞ Cihaz timeout nedeniyle kaldƒ±rƒ±ldƒ±: ${device['device_name']}');
        if (_onDeviceDisconnected != null) {
          final disconnectionInfo = {
            'device_id': device['device_id'],
            'device_name': device['device_name'],
            'reason': 'Connection timeout',
            'timestamp': DateTime.now().toIso8601String(),
          };
          _onDeviceDisconnected!(disconnectionInfo);
        }
      }
    } catch (e) {
      print('‚ùå Cleanup hatasƒ±: $e');
    }
  }

  // CORS headers ekle
  void _addCORSHeaders(HttpResponse response) {
    response.headers.add('Access-Control-Allow-Origin', '*');
    response.headers.add(
      'Access-Control-Allow-Methods',
      'GET, POST, PUT, DELETE, OPTIONS',
    );
    response.headers.add(
      'Access-Control-Allow-Headers',
      'Content-Type, Authorization',
    );
    response.headers.add('Content-Type', 'application/json; charset=utf-8');
  }

  // HTTP method validasyonu
  Future<String> _handleMethodValidation(
    HttpRequest request,
    String allowedMethod,
    Function(HttpRequest) handler,
  ) async {
    if (request.method != allowedMethod) {
      return _createErrorResponse(
        'Method not allowed',
        'Only $allowedMethod method is supported for this endpoint',
      );
    }
    return await handler(request);
  }

  // Error response olu≈ütur
  String _createErrorResponse(String error, String message) {
    return json.encode({
      'success': false,
      'error': error,
      'message': message,
      'timestamp': DateTime.now().toIso8601String(),
    });
  }

  // Response g√∂nder
  Future<void> _sendResponse(
    HttpResponse response,
    String body,
    int statusCode,
  ) async {
    try {
      final responseBytes = utf8.encode(body);
      response
        ..statusCode = statusCode
        ..add(responseBytes);
      await response.close();
    } catch (e) {
      print('‚ùå Response g√∂nderme hatasƒ±: $e');
    }
  }

  // Error response g√∂nder
  Future<void> _sendErrorResponse(
    HttpResponse response,
    String error,
    String message,
  ) async {
    try {
      final errorResponse = _createErrorResponse(error, message);
      await _sendResponse(response, errorResponse, 500);
    } catch (e) {
      print('‚ùå Error response g√∂nderme hatasƒ±: $e');
    }
  }

  Future<void> _cihazBilgileriniAl() async {
    final deviceInfo = DeviceInfoPlugin();

    try {
      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        _cihazAdi = '${androidInfo.brand} ${androidInfo.model}';
        _platform = 'Android ${androidInfo.version.release}';
        _cihazId = androidInfo.id;
      } else if (Platform.isWindows) {
        final windowsInfo = await deviceInfo.windowsInfo;
        _cihazAdi = windowsInfo.computerName;
        _platform = 'Windows';
        _cihazId = windowsInfo.deviceId;
      } else if (Platform.isLinux) {
        final linuxInfo = await deviceInfo.linuxInfo;
        _cihazAdi = linuxInfo.name;
        _platform = 'Linux';
        _cihazId =
            linuxInfo.machineId ??
            'linux-${DateTime.now().millisecondsSinceEpoch}';
      } else if (Platform.isMacOS) {
        final macInfo = await deviceInfo.macOsInfo;
        _cihazAdi = macInfo.computerName;
        _platform = 'macOS';
        _cihazId =
            macInfo.systemGUID ??
            'mac-${DateTime.now().millisecondsSinceEpoch}';
      } else {
        _cihazAdi = 'Bilinmeyen Cihaz';
        _platform = Platform.operatingSystem;
        _cihazId = 'unknown-${DateTime.now().millisecondsSinceEpoch}';
      }

      // Cihaz ID'sini hash'le (g√ºvenlik i√ßin)
      final cihazId = _cihazId ?? 'unknown-device';
      final bytes = utf8.encode(cihazId);
      final digest = sha256.convert(bytes);
      _cihazId = digest.toString().substring(0, 16);
    } catch (e) {
      print('‚ùå Cihaz bilgisi alƒ±namadƒ±: $e');
      _cihazAdi = 'Arsivim Cihazƒ±';
      _platform = Platform.operatingSystem;
      _cihazId = 'fallback-${DateTime.now().millisecondsSinceEpoch}';
    }
  }

  // HTTP Handler metodlarƒ±
  Future<String> _handlePing() async {
    return json.encode({
      'status': 'ok',
      'timestamp': DateTime.now().toIso8601String(),
      'device_id': _cihazId,
      'device_name': _cihazAdi,
      'platform': _platform,
      'server_version': '2.0.0',
    });
  }

  Future<String> _handleInfo() async {
    try {
      final belgeSayisi = await _veriTabani.toplamBelgeSayisi();
      final toplamBoyut = await _veriTabani.toplamDosyaBoyutu();
      final serverIP = await getRealIPAddress();

      return json.encode({
        'success': true,
        'app': UYGULAMA_KODU,
        'version': '2.0.0',
        'device_id': _cihazId,
        'device_name': _cihazAdi,
        'platform': _platform,
        'document_count': belgeSayisi,
        'total_size': toplamBoyut,
        'server_ip': serverIP,
        'server_port': SUNUCU_PORTU,
        'timestamp': DateTime.now().toIso8601String(),
        'server_running': true,
        'connected_devices': _bagliCihazlar.length,
        'max_file_size': _getMaxFileSize(),
      });
    } catch (e) {
      print('‚ùå Info endpoint hatasƒ±: $e');
      return json.encode({
        'success': false,
        'error': 'Info alƒ±namadƒ±',
        'message': e.toString(),
        'app': UYGULAMA_KODU,
        'version': '2.0.0',
        'device_id': _cihazId,
        'device_name': _cihazAdi,
        'platform': _platform,
        'timestamp': DateTime.now().toIso8601String(),
      });
    }
  }

  // Maksimum dosya boyutunu platform'a g√∂re d√∂nd√ºr
  int _getMaxFileSize() {
    return Platform.isAndroid || Platform.isIOS
        ? MAX_FILE_SIZE_MOBILE
        : MAX_FILE_SIZE_DESKTOP;
  }

  // Connection handler methods
  Future<String> _handleConnect(HttpRequest request) async {
    try {
      print('üîó Baƒülantƒ± isteƒüi alƒ±ndƒ±');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final deviceId = data['device_id'] as String?;
      final deviceName = data['device_name'] as String?;
      final platform = data['platform'] as String?;
      final clientIP =
          request.connectionInfo?.remoteAddress?.address ?? 'bilinmiyor';

      if (deviceId == null || deviceName == null) {
        return _createErrorResponse(
          'Missing parameters',
          'device_id ve device_name gerekli',
        );
      }

      // Cihaz zaten baƒülƒ± mƒ± kontrol et
      final mevcutCihazIndex = _bagliCihazlar.indexWhere(
        (device) => device['device_id'] == deviceId,
      );

      if (mevcutCihazIndex != -1) {
        // Mevcut cihazƒ±n bilgilerini g√ºncelle
        _bagliCihazlar[mevcutCihazIndex].addAll({
          'last_seen': DateTime.now().toIso8601String(),
          'status': 'connected',
          'online': true,
          'ip': clientIP,
          'platform': platform ?? _bagliCihazlar[mevcutCihazIndex]['platform'],
        });
        print('üîÑ Mevcut cihaz bilgileri g√ºncellendi: $deviceName ($deviceId)');

        // G√ºncelleme i√ßin UI bildirimini g√∂nder
        if (_onDeviceConnected != null) {
          print('üîÑ UI\'ya cihaz g√ºncelleme bildirimi g√∂nderiliyor...');
          Future.microtask(
            () => _onDeviceConnected!(_bagliCihazlar[mevcutCihazIndex]),
          );
        }
      } else {
        // Yeni cihaz ekle
        final yeniCihaz = {
          'device_id': deviceId,
          'device_name': deviceName,
          'platform': platform ?? 'Unknown',
          'ip': clientIP,
          'connected_at': DateTime.now().toIso8601String(),
          'last_seen': DateTime.now().toIso8601String(),
          'status': 'connected',
          'connection_type': 'incoming',
          'online': true,
        };

        _bagliCihazlar.add(yeniCihaz);
        print('‚ûï Yeni cihaz eklendi: $deviceName ($deviceId)');

        // UI'ya bildirim g√∂nder
        if (_onDeviceConnected != null) {
          print('üì± UI\'ya yeni cihaz baƒülantƒ± bildirimi g√∂nderiliyor...');
          Future.microtask(() => _onDeviceConnected!(yeniCihaz));
        }
      }

      final serverIP = await getRealIPAddress();
      final belgeSayisi = await _veriTabani.toplamBelgeSayisi();
      final toplamBoyut = await _veriTabani.toplamDosyaBoyutu();

      return json.encode({
        'success': true,
        'message': 'Baƒülantƒ± kuruldu',
        'server_device_id': _cihazId,
        'server_device_name': _cihazAdi,
        'server_ip': serverIP,
        'server_port': SUNUCU_PORTU,
        'server_info': {
          'platform': _platform,
          'document_count': belgeSayisi,
          'total_size': toplamBoyut,
        },
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Connect handler hatasƒ±: $e');
      return _createErrorResponse('Baƒülantƒ± hatasƒ±', e.toString());
    }
  }

  Future<String> _handleDisconnect(HttpRequest request) async {
    try {
      print('üîå Baƒülantƒ± kesme isteƒüi alƒ±ndƒ±');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final deviceId = data['device_id'] as String?;
      final reason = data['reason'] as String?;

      if (deviceId == null) {
        return _createErrorResponse('Missing parameter', 'device_id gerekli');
      }

      // Cihazƒ± listeden kaldƒ±r
      final removedDevice = _bagliCihazlar.firstWhere(
        (device) => device['device_id'] == deviceId,
        orElse: () => <String, dynamic>{},
      );

      if (removedDevice.isNotEmpty) {
        _bagliCihazlar.removeWhere((device) => device['device_id'] == deviceId);
        print(
          'üîå Cihaz baƒülantƒ±sƒ± kesildi: ${removedDevice['device_name']} ($deviceId)',
        );
        print('üìù Sebep: ${reason ?? 'Belirtilmedi'}');

        // UI'ya bildirim g√∂nder
        if (_onDeviceDisconnected != null) {
          final disconnectionInfo = {
            'device_id': deviceId,
            'device_name': removedDevice['device_name'],
            'reason': reason ?? 'Baƒülantƒ± kesildi',
            'timestamp': DateTime.now().toIso8601String(),
          };
          print('üì¢ UI\'ya baƒülantƒ± kesme bildirimi g√∂nderiliyor...');
          Future.microtask(() => _onDeviceDisconnected!(disconnectionInfo));
        }

        return json.encode({
          'success': true,
          'message': 'Baƒülantƒ± kesildi',
          'timestamp': DateTime.now().toIso8601String(),
        });
      } else {
        return _createErrorResponse(
          'Device not found',
          'Belirtilen cihaz baƒülƒ± cihazlar listesinde yok',
        );
      }
    } catch (e) {
      print('‚ùå Disconnect handler hatasƒ±: $e');
      return _createErrorResponse('Baƒülantƒ± kesme hatasƒ±', e.toString());
    }
  }

  Future<String> _handleStatus() async {
    try {
      final serverIP = await getRealIPAddress();
      final belgeSayisi = await _veriTabani.toplamBelgeSayisi();
      final toplamBoyut = await _veriTabani.toplamDosyaBoyutu();

      return json.encode({
        'success': true,
        'status': 'running',
        'server_info': {
          'device_id': _cihazId,
          'device_name': _cihazAdi,
          'platform': _platform,
          'ip': serverIP,
          'port': SUNUCU_PORTU,
          'document_count': belgeSayisi,
          'total_size': toplamBoyut,
        },
        'connected_devices': _bagliCihazlar.length,
        'uptime': DateTime.now().toIso8601String(),
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Status handler hatasƒ±: $e');
      return _createErrorResponse('Status alƒ±namadƒ±', e.toString());
    }
  }

  Future<String> _handleDevices() async {
    try {
      // Baƒülƒ± cihazlarƒ±n son g√∂r√ºlme zamanlarƒ±nƒ± kontrol et (cleanup timer zaten yapƒ±yor ama extra kontrol)
      final now = DateTime.now();
      final removedDevices = <Map<String, dynamic>>[];

      _bagliCihazlar.removeWhere((device) {
        final lastSeenStr = device['last_seen'] as String?;
        if (lastSeenStr == null) return true;

        final lastSeen = DateTime.tryParse(lastSeenStr);
        if (lastSeen == null) return true;

        final isTimedOut = now.difference(lastSeen) > CONNECTION_TIMEOUT;
        if (isTimedOut) {
          removedDevices.add(device);
        }
        return isTimedOut;
      });

      // Timeout olan cihazlar i√ßin bildirim g√∂nder
      for (final device in removedDevices) {
        print('‚è∞ Cihaz timeout nedeniyle kaldƒ±rƒ±ldƒ±: ${device['device_name']}');
        if (_onDeviceDisconnected != null) {
          final disconnectionInfo = {
            'device_id': device['device_id'],
            'device_name': device['device_name'],
            'reason': 'Connection timeout',
            'timestamp': DateTime.now().toIso8601String(),
          };
          Future.microtask(() => _onDeviceDisconnected!(disconnectionInfo));
        }
      }

      return json.encode({
        'success': true,
        'devices': _bagliCihazlar,
        'total_count': _bagliCihazlar.length,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Devices handler hatasƒ±: $e');
      return _createErrorResponse('Cihaz listesi alƒ±namadƒ±', e.toString());
    }
  }

  Future<String> _handleDeviceConnected(HttpRequest request) async {
    try {
      print('üì± Cihaz baƒülantƒ± bildirimi alƒ±ndƒ±');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final deviceId = data['device_id'] as String?;
      final deviceName = data['device_name'] as String?;
      final platform = data['platform'] as String?;
      final clientIP =
          request.connectionInfo?.remoteAddress?.address ?? 'bilinmiyor';

      if (deviceId == null || deviceName == null) {
        return _createErrorResponse(
          'Missing parameters',
          'device_id ve device_name gerekli',
        );
      }

      print('üÜï YENƒ∞ Cƒ∞HAZ BAƒûLANDI!');
      print('üì± Cihaz: $deviceName ($deviceId)');
      print('üíª Platform: $platform');
      print('üåê IP: $clientIP');

      // UI'ya bildirim g√∂nder
      final deviceInfo = {
        'device_id': deviceId,
        'device_name': deviceName,
        'platform': platform ?? 'Unknown',
        'ip': clientIP,
        'timestamp': DateTime.now().toIso8601String(),
        'connection_type': 'incoming',
      };

      // Callback'i √ßaƒüƒ±r
      if (_onDeviceConnected != null) {
        print('üì¢ UI\'ya baƒülantƒ± bildirimi g√∂nderiliyor...');
        Future.microtask(() => _onDeviceConnected!(deviceInfo));
      } else {
        print('‚ö†Ô∏è Device connected callback tanƒ±mlanmamƒ±≈ü!');
      }

      return json.encode({
        'success': true,
        'message': 'Baƒülantƒ± bildirimi alƒ±ndƒ±',
        'server_device_id': _cihazId,
        'server_device_name': _cihazAdi,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Device connected handler hatasƒ±: $e');
      return _createErrorResponse('Baƒülantƒ± bildirimi hatasƒ±', e.toString());
    }
  }

  Future<String> _handleDeviceDisconnected(HttpRequest request) async {
    try {
      print('üì± Cihaz baƒülantƒ± kesme bildirimi alƒ±ndƒ±');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final deviceId = data['device_id'] as String?;
      final message = data['message'] as String?;

      if (deviceId == null) {
        return _createErrorResponse('Missing parameter', 'device_id gerekli');
      }

      print('üîå Cihaz baƒülantƒ±sƒ± kesildi: $deviceId');
      print('üìù Mesaj: $message');

      // UI'ya bildirim g√∂nder
      final disconnectionInfo = {
        'device_id': deviceId,
        'message': message ?? 'Baƒülantƒ± kesildi',
        'timestamp': DateTime.now().toIso8601String(),
      };

      // Callback'i √ßaƒüƒ±r
      if (_onDeviceDisconnected != null) {
        print('üì¢ UI\'ya baƒülantƒ± kesme bildirimi g√∂nderiliyor...');
        Future.microtask(() => _onDeviceDisconnected!(disconnectionInfo));
      } else {
        print('‚ö†Ô∏è Device disconnected callback tanƒ±mlanmamƒ±≈ü!');
      }

      return json.encode({
        'success': true,
        'message': 'Baƒülantƒ± kesme bildirimi alƒ±ndƒ±',
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Device disconnected handler hatasƒ±: $e');
      return _createErrorResponse(
        'Baƒülantƒ± kesme bildirimi hatasƒ±',
        e.toString(),
      );
    }
  }

  // IP adresini ger√ßek zamanlƒ± al
  Future<String?> getRealIPAddress() async {
    try {
      print('üîç Network interface\'leri taranƒ±yor...');
      final interfaces = await NetworkInterface.list();

      String? bestIP;
      int bestPriority = 0;

      for (final interface in interfaces) {
        print(
          'üîó Interface: ${interface.name}, addresses: ${interface.addresses.length}',
        );

        for (final addr in interface.addresses) {
          if (addr.type == InternetAddressType.IPv4 && !addr.isLoopback) {
            print('üìç Address: ${addr.address}, Interface: ${interface.name}');

            int priority = 0;
            final interfaceName = interface.name.toLowerCase();

            // Virtual interface'leri atla
            if (interfaceName.contains('virtual') ||
                interfaceName.contains('vmware') ||
                interfaceName.contains('vbox') ||
                interfaceName.contains('virtualbox') ||
                interfaceName.contains('docker') ||
                interfaceName.contains('hyper-v')) {
              print('‚ö†Ô∏è Virtual interface atlandƒ±: ${interface.name}');
              continue;
            }

            // Wi-Fi interface'leri en y√ºksek √∂ncelik
            if (interfaceName.contains('wi-fi') ||
                interfaceName.contains('wlan') ||
                interfaceName.contains('wireless')) {
              priority = 100;
            }
            // Ethernet ikinci √∂ncelik
            else if (interfaceName.contains('ethernet') ||
                interfaceName.contains('eth')) {
              priority = 80;
            }
            // Diƒüer interface'ler
            else {
              priority = 50;
            }

            // 192.168.x.x aƒülarƒ± extra puan (ev/ofis aƒülarƒ±)
            if (addr.address.startsWith('192.168.')) {
              priority += 30;
            }
            // 10.x.x.x aƒülarƒ± da ge√ßerli ama daha az puan
            else if (addr.address.startsWith('10.')) {
              priority += 20;
            }
            // 172.16-31.x.x aƒülarƒ±
            else if (addr.address.startsWith('172.')) {
              final parts = addr.address.split('.');
              if (parts.length >= 2) {
                final second = int.tryParse(parts[1]);
                if (second != null && second >= 16 && second <= 31) {
                  priority += 15;
                }
              }
            }

            if (priority > bestPriority) {
              bestPriority = priority;
              bestIP = addr.address;
              print(
                '‚úÖ Yeni en iyi IP: ${addr.address} (√ñncelik: $priority, Interface: ${interface.name})',
              );
            }
          }
        }
      }

      if (bestIP != null) {
        print('üåê En iyi IP se√ßildi: $bestIP (√ñncelik: $bestPriority)');
        return bestIP;
      }

      print('‚ùå Uygun IP adresi bulunamadƒ±');
    } catch (e) {
      print('‚ùå IP adresi alƒ±namadƒ±: $e');
    }

    return null;
  }

  // Utility metodlarƒ±
  void clearConnectedDevices() {
    _bagliCihazlar.clear();
    print('üßπ Baƒülƒ± cihazlar listesi temizlendi');
  }

  void updateDeviceLastSeen(String deviceId) {
    final device = _bagliCihazlar.firstWhere(
      (device) => device['device_id'] == deviceId,
      orElse: () => <String, dynamic>{},
    );

    if (device.isNotEmpty) {
      device['last_seen'] = DateTime.now().toIso8601String();
      print('‚è∞ Cihaz son g√∂r√ºlme zamanƒ± g√ºncellendi: $deviceId');
    }
  }

  // Senkronizasyon Handler Metodlarƒ±

  /// Bekleyen senkronizasyon belgelerini d√∂nd√ºr (GET)
  Future<String> _handleSyncBelgeler() async {
    try {
      print('üìÑ Senkronizasyon bekleyen belgeler istendi');

      final belgeler = await _veriTabani.belgeleriGetir(limit: 50);
      final bekleyenBelgeler =
          belgeler
              .where(
                (belge) =>
                    belge.senkronDurumu == SenkronDurumu.BEKLEMEDE ||
                    belge.senkronDurumu == SenkronDurumu.YEREL_DEGISIM,
              )
              .toList();

      print('üìä ${bekleyenBelgeler.length} bekleyen belge bulundu');

      final belgelerJson = <Map<String, dynamic>>[];

      // Batch processing ile belgeleri hazƒ±rla
      for (int i = 0; i < bekleyenBelgeler.length; i += BATCH_SIZE) {
        final batch = bekleyenBelgeler.skip(i).take(BATCH_SIZE).toList();

        for (final belge in batch) {
          final belgeMap = belge.toMap();

          // Dosya boyutu kontrol√º ve dosya okuma
          try {
            final dosyaFile = File(belge.dosyaYolu);
            if (await dosyaFile.exists()) {
              final dosyaBytes = await dosyaFile.readAsBytes();
              final maxFileSize = _getMaxFileSize();

              if (dosyaBytes.length > maxFileSize) {
                print(
                  '‚ö†Ô∏è B√ºy√ºk dosya atlanƒ±yor: ${belge.dosyaAdi} (${dosyaBytes.length} bytes, limit: $maxFileSize)',
                );
                belgeMap['dosya_icerigi'] = null;
                belgeMap['buyuk_dosya'] = true;
                belgeMap['dosya_boyutu'] = dosyaBytes.length;
                belgeMap['dosya_hash_kontrol'] = belge.dosyaHash;
              } else if (dosyaBytes.isNotEmpty) {
                belgeMap['dosya_icerigi'] = base64Encode(dosyaBytes);
                belgeMap['buyuk_dosya'] = false;
                belgeMap['dosya_boyutu'] = dosyaBytes.length;
                belgeMap['dosya_hash_kontrol'] = belge.dosyaHash;
                print(
                  'üìÑ Belge hazƒ±rlandƒ±: ${belge.dosyaAdi} (${dosyaBytes.length} bytes)',
                );
              } else {
                print('‚ö†Ô∏è Dosya bo≈ü: ${belge.dosyaAdi}');
                belgeMap['dosya_icerigi'] = null;
                belgeMap['buyuk_dosya'] = false;
                belgeMap['dosya_boyutu'] = 0;
              }
            } else {
              print('‚ùå Dosya mevcut deƒüil: ${belge.dosyaYolu}');
              belgeMap['dosya_icerigi'] = null;
              belgeMap['buyuk_dosya'] = false;
              belgeMap['dosya_boyutu'] = 0;
              belgeMap['dosya_mevcut_degil'] = true;
            }
          } catch (e) {
            print('‚ùå Dosya okuma hatasƒ±: ${belge.dosyaAdi} - $e');
            belgeMap['dosya_icerigi'] = null;
            belgeMap['buyuk_dosya'] = false;
            belgeMap['dosya_boyutu'] = 0;
            belgeMap['dosya_okuma_hatasi'] = e.toString();
          }

          belgelerJson.add(belgeMap);
        }

        // Batch aralarƒ±nda kƒ±sa bekleme
        await Future.delayed(Duration.zero);
      }

      return json.encode({
        'success': true,
        'belgeler': belgelerJson,
        'toplam': bekleyenBelgeler.length,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Belge senkronizasyonu hatasƒ±: $e');
      return _createErrorResponse('Belgeler alƒ±namadƒ±', e.toString());
    }
  }

  /// Gelen belgeleri al ve kaydet (POST)
  Future<String> _handleReceiveBelgeler(HttpRequest request) async {
    try {
      print('üì• Belge senkronizasyonu alƒ±nƒ±yor');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final belgelerData = data['belgeler'] as List<dynamic>;
      int basariliSayisi = 0;
      int hataliSayisi = 0;

      // Batch processing ile belgeleri kaydet
      for (int i = 0; i < belgelerData.length; i += BATCH_SIZE) {
        final batch = belgelerData.skip(i).take(BATCH_SIZE).toList();

        for (final belgeData in batch) {
          try {
            // Belge modelini olu≈ütur
            final belge = BelgeModeli.fromMap(belgeData);

            // Belge zaten mevcut mu kontrol et
            final mevcutBelge = await _veriTabani.belgeBulHash(belge.dosyaHash);
            if (mevcutBelge != null) {
              print('‚è≠Ô∏è Belge zaten mevcut: ${belge.dosyaAdi}');
              continue;
            }

            // Dosya i√ßeriƒüini kaydet
            if (belgeData['dosya_icerigi'] != null &&
                belgeData['dosya_icerigi'].toString().isNotEmpty) {
              try {
                final dosyaBytes = base64Decode(belgeData['dosya_icerigi']);

                if (dosyaBytes.isNotEmpty) {
                  // Hash doƒürulamasƒ±
                  final hesaplananHash = sha256.convert(dosyaBytes).toString();
                  final beklenenHash =
                      belgeData['dosya_hash_kontrol'] ?? belge.dosyaHash;

                  if (hesaplananHash != beklenenHash) {
                    print(
                      '‚ùå Hash uyumsuzluƒüu: ${belge.dosyaAdi} (beklenen: $beklenenHash, hesaplanan: $hesaplananHash)',
                    );
                    hataliSayisi++;
                    continue;
                  }

                  final dosyaYolu = await _dosyaServisi.senkronDosyasiKaydet(
                    belge.dosyaAdi,
                    dosyaBytes,
                  );

                  // Dosya yolunu g√ºncelle
                  final yeniBelge = belge.copyWith(
                    dosyaYolu: dosyaYolu,
                    senkronDurumu: SenkronDurumu.SENKRONIZE,
                  );

                  // Veritabanƒ±na kaydet
                  await _veriTabani.belgeEkle(yeniBelge);
                  basariliSayisi++;
                  print(
                    '‚úÖ Belge kaydedildi: ${belge.dosyaAdi} (${dosyaBytes.length} bytes)',
                  );
                } else {
                  print('‚ö†Ô∏è Belge i√ßeriƒüi bo≈ü: ${belge.dosyaAdi}');
                  hataliSayisi++;
                }
              } catch (e) {
                print('‚ùå Belge decode/kaydetme hatasƒ±: ${belge.dosyaAdi} - $e');
                hataliSayisi++;
              }
            } else if (belgeData['buyuk_dosya'] == true) {
              print('üìã B√ºy√ºk dosya metadata kaydediliyor: ${belge.dosyaAdi}');
              // B√ºy√ºk dosyalar i√ßin sadece metadata kaydet
              final metadataBelge = belge.copyWith(
                dosyaYolu: '', // Bo≈ü dosya yolu
                senkronDurumu:
                    SenkronDurumu.BEKLEMEDE, // Dosya i√ßeriƒüi beklemede
              );
              await _veriTabani.belgeEkle(metadataBelge);
              basariliSayisi++;
            } else {
              print('‚ö†Ô∏è Belge i√ßeriƒüi bulunamadƒ±: ${belge.dosyaAdi}');
              hataliSayisi++;
            }
          } catch (e) {
            print('‚ùå Belge i≈üleme hatasƒ±: $e');
            hataliSayisi++;
          }
        }

        // Batch aralarƒ±nda kƒ±sa bekleme
        await Future.delayed(Duration.zero);
      }

      return json.encode({
        'success': true,
        'message': 'Belge senkronizasyonu tamamlandƒ±',
        'basarili': basariliSayisi,
        'hatali': hataliSayisi,
        'toplam': belgelerData.length,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Belge alma hatasƒ±: $e');
      return _createErrorResponse('Belgeler kaydedilemedi', e.toString());
    }
  }

  /// Kapsamlƒ± belge senkronizasyonu (Dependency-Aware)
  Future<String> _handleReceiveBelgelerKapsamli(HttpRequest request) async {
    try {
      print('üì• Kapsamlƒ± belge senkronizasyonu alƒ±nƒ±yor');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final belgelerData = data['belgeler'] as List<dynamic>;
      final kisilerData = data['kisiler'] as List<dynamic>;
      final kategorilerData = data['kategoriler'] as List<dynamic>;

      int belgelerEklendi = 0;
      int kisilerEklendi = 0;
      int kategorilerEklendi = 0;
      int hatalar = 0;

      // Batch processing ile sƒ±ralƒ± i≈ülem
      try {
        // 1. √ñnce kategorileri ekle
        for (int i = 0; i < kategorilerData.length; i += BATCH_SIZE) {
          final batch = kategorilerData.skip(i).take(BATCH_SIZE).toList();

          for (final kategoriData in batch) {
            try {
              final kategori = KategoriModeli.fromMap(kategoriData);

              // Kategori zaten var mƒ± kontrol et
              final mevcutKategori = await _veriTabani.kategoriBulAd(
                kategori.ad,
              );
              if (mevcutKategori == null) {
                // Kategori ID'sini korumak i√ßin √∂zel ekleme
                final eskiTarihliKategori = kategori.copyWith(
                  olusturmaTarihi: DateTime.now().subtract(
                    const Duration(days: 2),
                  ),
                );
                await _veriTabani.kategoriEkleIdIle(eskiTarihliKategori);
                kategorilerEklendi++;
                print('‚úÖ Kategori eklendi: ${kategori.ad}');
              } else {
                print('‚è≠Ô∏è Kategori zaten mevcut: ${kategori.ad}');
              }
            } catch (e) {
              print('‚ùå Kategori ekleme hatasƒ±: $e');
              hatalar++;
            }
          }
          await Future.delayed(Duration.zero);
        }

        // 2. Sonra ki≈üileri ekle
        for (int i = 0; i < kisilerData.length; i += BATCH_SIZE) {
          final batch = kisilerData.skip(i).take(BATCH_SIZE).toList();

          for (final kisiData in batch) {
            try {
              final kisi = KisiModeli.fromMap(kisiData);

              // Ki≈üi zaten var mƒ± kontrol et
              final mevcutKisi = await _veriTabani.kisiBulAdSoyad(
                kisi.ad,
                kisi.soyad,
              );
              if (mevcutKisi == null) {
                // Ki≈üi ID'sini korumak i√ßin √∂zel ekleme
                final eskiTarihliKisi = kisi.copyWith(
                  olusturmaTarihi: DateTime.now().subtract(
                    const Duration(days: 2),
                  ),
                );
                await _veriTabani.kisiEkleIdIle(eskiTarihliKisi);
                kisilerEklendi++;
                print('‚úÖ Ki≈üi eklendi: ${kisi.ad} ${kisi.soyad}');
              } else {
                print('‚è≠Ô∏è Ki≈üi zaten mevcut: ${kisi.ad} ${kisi.soyad}');
              }
            } catch (e) {
              print('‚ùå Ki≈üi ekleme hatasƒ±: $e');
              hatalar++;
            }
          }
          await Future.delayed(Duration.zero);
        }

        // 3. Son olarak belgeleri ekle
        for (int i = 0; i < belgelerData.length; i += BATCH_SIZE) {
          final batch = belgelerData.skip(i).take(BATCH_SIZE).toList();

          for (final belgeData in batch) {
            try {
              final belge = BelgeModeli.fromMap(belgeData);

              // Ki≈üi ID'sini doƒüru ≈üekilde e≈üle≈ütir
              int? dogruKisiId;
              if (belgeData['kisi_ad'] != null &&
                  belgeData['kisi_soyad'] != null) {
                final kisiAd = belgeData['kisi_ad'] as String;
                final kisiSoyad = belgeData['kisi_soyad'] as String;

                final mevcutKisi = await _veriTabani.kisiBulAdSoyad(
                  kisiAd,
                  kisiSoyad,
                );
                if (mevcutKisi != null) {
                  dogruKisiId = mevcutKisi.id;
                  print(
                    'üë§ Ki≈üi e≈üle≈ütirildi: $kisiAd $kisiSoyad (ID: $dogruKisiId)',
                  );
                } else {
                  print(
                    '‚ö†Ô∏è Ki≈üi bulunamadƒ±: $kisiAd $kisiSoyad - Eski ID korunuyor',
                  );
                  dogruKisiId = belge.kisiId;
                }
              } else {
                dogruKisiId = belge.kisiId;
              }

              // Kategori ID'sini doƒüru ≈üekilde e≈üle≈ütir
              int? dogruKategoriId;
              if (belgeData['kategori_adi'] != null) {
                final kategoriAdi = belgeData['kategori_adi'] as String;

                final mevcutKategori = await _veriTabani.kategoriBulAd(
                  kategoriAdi,
                );
                if (mevcutKategori != null) {
                  dogruKategoriId = mevcutKategori.id;
                  print(
                    'üìÅ Kategori e≈üle≈ütirildi: $kategoriAdi (ID: $dogruKategoriId)',
                  );
                } else {
                  print(
                    '‚ö†Ô∏è Kategori bulunamadƒ±: $kategoriAdi - Eski ID korunuyor',
                  );
                  dogruKategoriId = belge.kategoriId;
                }
              } else {
                dogruKategoriId = belge.kategoriId;
              }

              // Dosya i√ßeriƒüini kaydet
              if (belgeData['dosya_icerigi'] != null) {
                final dosyaBytes = base64Decode(belgeData['dosya_icerigi']);
                final dosyaYolu = await _dosyaServisi.senkronDosyasiKaydet(
                  belge.dosyaAdi,
                  dosyaBytes,
                );

                // Belgeyi doƒüru ki≈üi ve kategori ID'leri ile g√ºncelle
                final yeniBelge = belge.copyWith(
                  dosyaYolu: dosyaYolu,
                  kisiId: dogruKisiId,
                  kategoriId: dogruKategoriId,
                  senkronDurumu: SenkronDurumu.SENKRONIZE,
                );

                // Belge zaten var mƒ± kontrol et
                final mevcutBelge = await _veriTabani.belgeBulHash(
                  belge.dosyaHash,
                );
                if (mevcutBelge == null) {
                  await _veriTabani.belgeEkle(yeniBelge);
                  belgelerEklendi++;
                  print(
                    '‚úÖ Belge kaydedildi: ${belge.dosyaAdi} (Ki≈üi: $dogruKisiId, Kategori: $dogruKategoriId)',
                  );
                } else {
                  print('‚è≠Ô∏è Belge zaten mevcut: ${belge.dosyaAdi}');
                  // Mevcut belgenin ki≈üi/kategori bilgilerini g√ºncelle
                  final guncellenmisBelge = mevcutBelge.copyWith(
                    kisiId: dogruKisiId,
                    kategoriId: dogruKategoriId,
                    baslik: belge.baslik,
                    aciklama: belge.aciklama,
                    etiketler: belge.etiketler,
                    guncellemeTarihi: DateTime.now(),
                  );
                  await _veriTabani.belgeGuncelle(guncellenmisBelge);
                  print('üîÑ Belge metadata g√ºncellendi: ${belge.dosyaAdi}');
                }
              } else {
                print('‚ö†Ô∏è Belge i√ßeriƒüi bulunamadƒ±: ${belge.dosyaAdi}');
                hatalar++;
              }
            } catch (e) {
              print('‚ùå Belge kaydetme hatasƒ±: $e');
              hatalar++;
            }
          }
          await Future.delayed(Duration.zero);
        }

        print('üìä Kapsamlƒ± senkronizasyon tamamlandƒ±:');
        print('   ‚Ä¢ Kategoriler: $kategorilerEklendi');
        print('   ‚Ä¢ Ki≈üiler: $kisilerEklendi');
        print('   ‚Ä¢ Belgeler: $belgelerEklendi');
        print('   ‚Ä¢ Hatalar: $hatalar');
      } catch (e) {
        print('‚ùå Senkronizasyon hatasƒ±: $e');
        throw e;
      }

      return json.encode({
        'success': true,
        'message': 'Kapsamlƒ± senkronizasyon tamamlandƒ±',
        'sonuc': {
          'kategoriler_eklendi': kategorilerEklendi,
          'kisiler_eklendi': kisilerEklendi,
          'belgeler_eklendi': belgelerEklendi,
          'hatalar': hatalar,
        },
        'toplam': {
          'kategoriler': kategorilerData.length,
          'kisiler': kisilerData.length,
          'belgeler': belgelerData.length,
        },
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Kapsamlƒ± senkronizasyon hatasƒ±: $e');
      return _createErrorResponse(
        'Kapsamlƒ± senkronizasyon ba≈üarƒ±sƒ±z',
        e.toString(),
      );
    }
  }

  /// Bekleyen senkronizasyon ki≈üilerini d√∂nd√ºr (GET)
  Future<String> _handleSyncKisiler() async {
    try {
      print('üë§ Senkronizasyon bekleyen ki≈üiler istendi');

      final kisiler = await _veriTabani.kisileriGetir();
      // Sadece son 6 saatte olu≈üturulan ki≈üileri bekleyen olarak kabul et
      final altiSaatOnce = DateTime.now().subtract(const Duration(hours: 6));
      final bekleyenKisiler =
          kisiler
              .where((kisi) => kisi.olusturmaTarihi.isAfter(altiSaatOnce))
              .toList();

      print('üìä ${bekleyenKisiler.length} bekleyen ki≈üi bulundu');

      final kisilerJson = <Map<String, dynamic>>[];

      // Batch processing ile ki≈üileri hazƒ±rla
      for (int i = 0; i < bekleyenKisiler.length; i += BATCH_SIZE) {
        final batch = bekleyenKisiler.skip(i).take(BATCH_SIZE).toList();

        for (final kisi in batch) {
          final kisiMap = kisi.toMap();

          // Profil fotoƒürafƒ±nƒ± dahil et - standardize key naming
          if (kisi.profilFotografi != null &&
              kisi.profilFotografi!.isNotEmpty) {
            try {
              final profilFile = File(kisi.profilFotografi!);
              if (await profilFile.exists()) {
                final dosyaBytes = await profilFile.readAsBytes();
                if (dosyaBytes.isNotEmpty &&
                    dosyaBytes.length <= MAX_PROFILE_PHOTO_SIZE) {
                  kisiMap['profil_fotografi_icerigi'] = base64Encode(
                    dosyaBytes,
                  );
                  kisiMap['profil_fotografi_dosya_adi'] = path.basename(
                    kisi.profilFotografi!,
                  );
                  print(
                    'üì∏ Profil fotoƒürafƒ± dahil edildi: ${kisi.ad} ${kisi.soyad} (${dosyaBytes.length} bytes)',
                  );
                } else {
                  print(
                    '‚ö†Ô∏è Profil fotoƒürafƒ± √ßok b√ºy√ºk veya bo≈ü: ${kisi.ad} ${kisi.soyad}',
                  );
                  kisiMap['profil_fotografi_icerigi'] = null;
                  kisiMap['profil_fotografi_dosya_adi'] = null;
                }
              } else {
                print(
                  '‚ö†Ô∏è Profil fotoƒürafƒ± dosyasƒ± mevcut deƒüil: ${kisi.profilFotografi}',
                );
                kisiMap['profil_fotografi_icerigi'] = null;
                kisiMap['profil_fotografi_dosya_adi'] = null;
              }
            } catch (e) {
              print(
                '‚ùå Profil fotoƒürafƒ± okuma hatasƒ±: ${kisi.ad} ${kisi.soyad} - $e',
              );
              kisiMap['profil_fotografi_icerigi'] = null;
              kisiMap['profil_fotografi_dosya_adi'] = null;
            }
          } else {
            kisiMap['profil_fotografi_icerigi'] = null;
            kisiMap['profil_fotografi_dosya_adi'] = null;
          }

          kisilerJson.add(kisiMap);
        }

        await Future.delayed(Duration.zero);
      }

      return json.encode({
        'success': true,
        'kisiler': kisilerJson,
        'toplam': bekleyenKisiler.length,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Ki≈üi senkronizasyonu hatasƒ±: $e');
      return _createErrorResponse('Ki≈üiler alƒ±namadƒ±', e.toString());
    }
  }

  /// Ki≈üileri al ve kar≈üƒ± tarafa kaydet (POST) - Standardized key naming
  Future<String> _handleReceiveKisiler(HttpRequest request) async {
    try {
      print('üë• Ki≈üi senkronizasyonu alƒ±nƒ±yor');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final kisilerData = data['kisiler'] as List<dynamic>;
      int basariliSayisi = 0;
      int hataliSayisi = 0;
      int guncellenmisSayisi = 0;

      print('üì¶ ${kisilerData.length} ki≈üi verisi alƒ±ndƒ±');

      // Batch processing ile ki≈üileri kaydet
      for (int i = 0; i < kisilerData.length; i += BATCH_SIZE) {
        final batch = kisilerData.skip(i).take(BATCH_SIZE).toList();

        for (final kisiData in batch) {
          try {
            final kisi = KisiModeli.fromMap(kisiData);

            // Profil fotoƒürafƒ±nƒ± kaydet - standardized key naming
            if (kisiData['profil_fotografi_icerigi'] != null) {
              try {
                final profilBytes = base64Decode(
                  kisiData['profil_fotografi_icerigi'],
                );

                // Dosya boyutu kontrol√º
                if (profilBytes.length > MAX_PROFILE_PHOTO_SIZE) {
                  print('‚ö†Ô∏è Profil fotoƒürafƒ± √ßok b√ºy√ºk: ${kisi.tamAd}');
                  await _saveKisiWithoutPhoto(kisi);
                  basariliSayisi++;
                  continue;
                }

                final dosyaAdi = '${kisi.ad}_${kisi.soyad}_profil.jpg';
                final profilYolu = await _dosyaServisi.senkronDosyasiKaydet(
                  dosyaAdi,
                  profilBytes,
                );

                // Profil fotoƒürafƒ± yolunu g√ºncelle
                final yeniKisi = kisi.copyWith(
                  profilFotografi: profilYolu,
                  guncellemeTarihi: DateTime.now(),
                  // Senkronizasyon sƒ±rasƒ±nda gelen ki≈üileri bekleyen listesinden √ßƒ±karmak i√ßin
                  olusturmaTarihi: DateTime.now().subtract(
                    const Duration(days: 2),
                  ),
                );

                // Ki≈üi zaten var mƒ± kontrol et
                final mevcutKisi = await _veriTabani.kisiBulAdSoyad(
                  kisi.ad,
                  kisi.soyad,
                );

                if (mevcutKisi == null) {
                  await _veriTabani.kisiEkle(yeniKisi);
                  basariliSayisi++;
                  print('‚úÖ Yeni ki≈üi eklendi: ${kisi.tamAd}');
                } else {
                  final guncellenmisKisi = yeniKisi.copyWith(id: mevcutKisi.id);
                  await _veriTabani.kisiGuncelle(guncellenmisKisi);
                  guncellenmisSayisi++;
                  print('üîÑ Ki≈üi g√ºncellendi: ${kisi.tamAd}');
                }
              } catch (e) {
                print('‚ö†Ô∏è Profil fotoƒürafƒ± kaydedilemedi: $e');
                await _saveKisiWithoutPhoto(kisi);
                basariliSayisi++;
              }
            } else {
              await _saveKisiWithoutPhoto(kisi);
              basariliSayisi++;
            }
          } catch (e) {
            print('‚ùå Ki≈üi kaydedilemedi: $e');
            hataliSayisi++;
          }
        }

        await Future.delayed(Duration.zero);
      }

      print('üìä Ki≈üi senkronizasyon sonucu:');
      print('   ‚Ä¢ Ba≈üarƒ±lƒ±: $basariliSayisi');
      print('   ‚Ä¢ G√ºncellenen: $guncellenmisSayisi');
      print('   ‚Ä¢ Hatalƒ±: $hataliSayisi');

      return json.encode({
        'success': true,
        'message': 'Ki≈üi senkronizasyonu tamamlandƒ±',
        'basarili': basariliSayisi,
        'guncellenen': guncellenmisSayisi,
        'hatali': hataliSayisi,
        'toplam': kisilerData.length,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Ki≈üi senkronizasyon hatasƒ±: $e');
      return _createErrorResponse('Ki≈üiler kaydedilemedi', e.toString());
    }
  }

  /// Profil fotoƒürafƒ± olmadan ki≈üiyi kaydet
  Future<void> _saveKisiWithoutPhoto(KisiModeli kisi) async {
    try {
      final mevcutKisi = await _veriTabani.kisiBulAdSoyad(kisi.ad, kisi.soyad);

      if (mevcutKisi == null) {
        final yeniKisi = kisi.copyWith(
          olusturmaTarihi: DateTime.now().subtract(const Duration(days: 2)),
          guncellemeTarihi: DateTime.now(),
        );
        await _veriTabani.kisiEkle(yeniKisi);
        print('‚úÖ Yeni ki≈üi eklendi (profil fotoƒürafƒ± yok): ${kisi.tamAd}');
      } else {
        final guncellenmisKisi = kisi.copyWith(
          id: mevcutKisi.id,
          guncellemeTarihi: DateTime.now(),
        );
        await _veriTabani.kisiGuncelle(guncellenmisKisi);
        print('üîÑ Ki≈üi g√ºncellendi (profil fotoƒürafƒ± yok): ${kisi.tamAd}');
      }
    } catch (e) {
      print('‚ùå Ki≈üi kaydetme hatasƒ±: $e');
    }
  }

  /// Bekleyen senkronizasyon kategorilerini d√∂nd√ºr (GET)
  Future<String> _handleSyncKategoriler() async {
    try {
      print('üìÅ Senkronizasyon bekleyen kategoriler istendi');

      final kategoriler = await _veriTabani.kategorileriGetir();

      // Kategori optimizasyonu: Sadece bug√ºnden itibaren eklenen kategorileri bekleyen olarak kabul et
      // Mevcut 16 kategori her iki sistemde de var, onlarƒ± senkronize etmeye gerek yok
      final bugun = DateTime.now();
      final bugunBaslangic = DateTime(bugun.year, bugun.month, bugun.day);

      final bekleyenKategoriler =
          kategoriler
              .where(
                (kategori) => kategori.olusturmaTarihi.isAfter(bugunBaslangic),
              )
              .toList();

      print(
        'üìä ${bekleyenKategoriler.length} bekleyen kategori bulundu (sadece bug√ºn eklenenler)',
      );
      print(
        'üìÖ Kategori filtresi: ${bugunBaslangic.toIso8601String()} sonrasƒ±',
      );

      final kategorilerJson =
          bekleyenKategoriler.map((kategori) => kategori.toMap()).toList();

      return json.encode({
        'success': true,
        'kategoriler': kategorilerJson,
        'toplam': bekleyenKategoriler.length,
        'filtre_tarihi': bugunBaslangic.toIso8601String(),
        'aciklama': 'Sadece bug√ºn eklenen kategoriler dahil edildi',
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Kategori senkronizasyonu hatasƒ±: $e');
      return _createErrorResponse('Kategoriler alƒ±namadƒ±', e.toString());
    }
  }

  /// Gelen kategorileri al ve kaydet (POST)
  Future<String> _handleReceiveKategoriler(HttpRequest request) async {
    try {
      print('üì• Kategori senkronizasyonu alƒ±nƒ±yor');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final kategorilerData = data['kategoriler'] as List<dynamic>;
      int basariliSayisi = 0;
      int hataliSayisi = 0;
      int guncellenmisSayisi = 0;

      // Batch processing ile kategorileri kaydet
      for (int i = 0; i < kategorilerData.length; i += BATCH_SIZE) {
        final batch = kategorilerData.skip(i).take(BATCH_SIZE).toList();

        for (final kategoriData in batch) {
          try {
            final kategori = KategoriModeli.fromMap(kategoriData);

            // Kategori zaten var mƒ± kontrol et
            final mevcutKategori = await _veriTabani.kategoriBulAd(kategori.ad);

            if (mevcutKategori == null) {
              // Yeni kategori ekle - senkronizasyondan gelen kategorileri bekleyen listesinden √ßƒ±karmak i√ßin
              final eskiTarihliKategori = kategori.copyWith(
                olusturmaTarihi: DateTime.now().subtract(
                  const Duration(days: 2),
                ),
              );
              await _veriTabani.kategoriEkle(eskiTarihliKategori);
              basariliSayisi++;
              print('‚úÖ Kategori kaydedildi: ${kategori.ad}');
            } else {
              // Mevcut kategoriyi g√ºncelle
              final guncellenmisKategori = kategori.copyWith(
                id: mevcutKategori.id,
                kategoriAdi: kategori.kategoriAdi,
                renkKodu: kategori.renkKodu,
                simgeKodu: kategori.simgeKodu,
                aciklama: kategori.aciklama,
                // Eski tarih vererek bekleyen listesinden √ßƒ±kar
                olusturmaTarihi: DateTime.now().subtract(
                  const Duration(days: 2),
                ),
              );
              await _veriTabani.kategoriGuncelle(guncellenmisKategori);
              guncellenmisSayisi++;
              print('üîÑ Kategori g√ºncellendi: ${kategori.ad}');
            }
          } catch (e) {
            print('‚ùå Kategori kaydetme hatasƒ±: $e');
            hataliSayisi++;
          }
        }

        await Future.delayed(Duration.zero);
      }

      return json.encode({
        'success': true,
        'message': 'Kategori senkronizasyonu tamamlandƒ±',
        'basarili': basariliSayisi,
        'guncellenen': guncellenmisSayisi,
        'hatali': hataliSayisi,
        'toplam': kategorilerData.length,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Kategori alma hatasƒ±: $e');
      return _createErrorResponse('Kategoriler kaydedilemedi', e.toString());
    }
  }

  /// Bekleyen senkronizasyonlarƒ±n √∂zet bilgisini d√∂nd√ºr
  Future<String> _handleBekleyenSenkronlar() async {
    try {
      print('üìã Bekleyen senkronizasyonlar sorgulandƒ±');

      final belgeler = await _veriTabani.belgeleriGetir();
      final bekleyenBelgeler =
          belgeler
              .where(
                (belge) =>
                    belge.senkronDurumu == SenkronDurumu.BEKLEMEDE ||
                    belge.senkronDurumu == SenkronDurumu.YEREL_DEGISIM,
              )
              .length;

      final kisiler = await _veriTabani.kisileriGetir();
      final altiSaatOnce = DateTime.now().subtract(const Duration(hours: 6));
      final bekleyenKisiler =
          kisiler
              .where((kisi) => kisi.olusturmaTarihi.isAfter(altiSaatOnce))
              .length;

      final kategoriler = await _veriTabani.kategorileriGetir();

      // Kategori optimizasyonu: Sadece bug√ºnden itibaren eklenen kategorileri bekleyen olarak kabul et
      // Mevcut 16 kategori her iki sistemde de var, onlarƒ± senkronize etmeye gerek yok
      final bugun = DateTime.now();
      final bugunBaslangic = DateTime(bugun.year, bugun.month, bugun.day);

      final bekleyenKategoriler =
          kategoriler
              .where(
                (kategori) => kategori.olusturmaTarihi.isAfter(bugunBaslangic),
              )
              .length;

      return json.encode({
        'success': true,
        'bekleyen_belgeler': bekleyenBelgeler,
        'bekleyen_kisiler': bekleyenKisiler,
        'bekleyen_kategoriler': bekleyenKategoriler,
        'toplam_bekleyen':
            bekleyenBelgeler + bekleyenKisiler + bekleyenKategoriler,
        'kategori_filtre_aciklama': 'Sadece bug√ºn eklenen kategoriler dahil',
        'kategori_filtre_tarihi': bugunBaslangic.toIso8601String(),
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Bekleyen senkronizasyon sorgu hatasƒ±: $e');
      return _createErrorResponse(
        'Bekleyen senkronizasyonlar sorgulanamadƒ±',
        e.toString(),
      );
    }
  }

  /// Senkronizasyon durumu bilgisini d√∂nd√ºr
  Future<String> _handleSyncStatus() async {
    try {
      print('üìä Senkronizasyon durumu sorgulandƒ±');

      final belgeler = await _veriTabani.belgeleriGetir();
      final senkronizeDurumlari = <String, int>{};

      for (final durum in SenkronDurumu.values) {
        senkronizeDurumlari[durum.toString()] =
            belgeler.where((belge) => belge.senkronDurumu == durum).length;
      }

      final toplamBelgeSayisi = belgeler.length;
      final senkronizeBelgeSayisi =
          belgeler
              .where((belge) => belge.senkronDurumu == SenkronDurumu.SENKRONIZE)
              .length;

      return json.encode({
        'success': true,
        'toplam_belge': toplamBelgeSayisi,
        'senkronize_belge': senkronizeBelgeSayisi,
        'senkronizasyon_orani':
            toplamBelgeSayisi > 0
                ? (senkronizeBelgeSayisi / toplamBelgeSayisi * 100).round()
                : 0,
        'durum_detaylari': senkronizeDurumlari,
        'bagli_cihaz_sayisi': _bagliCihazlar.length,
        'sunucu_aktif': _calisiyorMu,
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå Senkronizasyon durumu sorgu hatasƒ±: $e');
      return _createErrorResponse(
        'Senkronizasyon durumu sorgulanamadƒ±',
        e.toString(),
      );
    }
  }

  /// QR Login endpoint'i
  Future<String> _handleQRLogin(HttpRequest request) async {
    try {
      print('üì± QR Login isteƒüi alƒ±ndƒ±');

      final bodyBytes = await request.fold<List<int>>(
        <int>[],
        (previous, element) => previous..addAll(element),
      );
      final body = utf8.decode(bodyBytes);
      final data = json.decode(body);

      final kullaniciAdi = data['kullanici_adi'] as String?;
      final token = data['token'] as String?;
      final deviceId = data['device_id'] as String?;
      final deviceName = data['device_name'] as String?;
      final platform = data['platform'] as String?;
      final userInfo = data['user_info'] as Map<String, dynamic>?;

      print('üìä QR Login verileri:');
      print('  - Kullanƒ±cƒ±: $kullaniciAdi');
      print('  - Token: $token');
      print('  - Device ID: $deviceId');
      print('  - Device Name: $deviceName');
      print('  - Platform: $platform');
      print('  - User Info: ${userInfo != null ? 'Mevcut' : 'Yok'}');

      if (kullaniciAdi == null || token == null) {
        print('‚ùå Eksik veri: kullanici_adi ve token gerekli');
        return _createErrorResponse(
          'Missing parameters',
          'kullanici_adi ve token gerekli',
        );
      }

      // Kullanƒ±cƒ± bilgilerini kontrol et ve gerekirse otomatik kayƒ±t yap
      if (userInfo != null) {
        print('üë§ Kullanƒ±cƒ± bilgileri kontrol ediliyor...');
        await _ensureUserExists(userInfo);
      }

      // QR Login callback'ini √ßaƒüƒ±r
      if (_onQRLoginRequest != null) {
        print('üîë QR Login callback √ßaƒüƒ±rƒ±lƒ±yor: $kullaniciAdi');

        _onQRLoginRequest!({
          'kullanici_adi': kullaniciAdi,
          'token': token,
          'device_id': deviceId,
          'device_name': deviceName,
          'platform': platform,
          'user_info': userInfo,
        });

        print('‚úÖ QR Login callback √ßaƒüƒ±rƒ±ldƒ±');
      } else {
        print('‚ùå QR Login callback tanƒ±mlanmamƒ±≈ü!');
      }

      return json.encode({
        'success': true,
        'message': 'QR Login isteƒüi alƒ±ndƒ±',
        'timestamp': DateTime.now().toIso8601String(),
      });
    } catch (e) {
      print('‚ùå QR Login handler hatasƒ±: $e');
      return _createErrorResponse('QR Login hatasƒ±', e.toString());
    }
  }

  /// Kullanƒ±cƒ± adƒ± ile kullanƒ±cƒ± getir
  Future<KisiModeli?> _getUserByUsername(String kullaniciAdi) async {
    try {
      final db = await _veriTabani.database;
      final result = await db.query(
        'kisiler',
        where: 'kullanici_adi = ? AND aktif = ?',
        whereArgs: [kullaniciAdi, 1],
      );

      if (result.isNotEmpty) {
        return KisiModeli.fromMap(result.first);
      }
      return null;
    } catch (e) {
      print('‚ùå Kullanƒ±cƒ± getir hatasƒ±: $e');
      return null;
    }
  }

  /// Kullanƒ±cƒ±nƒ±n var olduƒüundan emin ol, yoksa otomatik kayƒ±t yap
  Future<void> _ensureUserExists(Map<String, dynamic> userInfo) async {
    try {
      final kullaniciAdi = userInfo['kullanici_adi'] as String?;
      if (kullaniciAdi == null) return;

      print('üîç Kullanƒ±cƒ± kontrol ediliyor: $kullaniciAdi');

      final existingUser = await _getUserByUsername(kullaniciAdi);

      if (existingUser == null) {
        print('‚ûï Kullanƒ±cƒ± bulunamadƒ±, otomatik kayƒ±t yapƒ±lƒ±yor...');

        final yeniKullanici = KisiModeli(
          ad: userInfo['ad'] ?? 'Bilinmeyen',
          soyad: userInfo['soyad'] ?? 'Kullanƒ±cƒ±',
          kullaniciAdi: kullaniciAdi,
          sifre: null, // QR login i√ßin ≈üifre gerekmez
          kullaniciTipi: userInfo['kullanici_tipi'] ?? 'kullanici',
          profilFotografi: userInfo['profil_fotografi'],
          olusturmaTarihi: DateTime.now(),
          guncellemeTarihi: DateTime.now(),
          aktif: true,
        );

        await _veriTabani.kisiEkle(yeniKullanici);
        print('‚úÖ Kullanƒ±cƒ± otomatik kayƒ±t edildi: $kullaniciAdi');

        await _registerDevice(kullaniciAdi, userInfo);
      } else {
        print('‚úÖ Kullanƒ±cƒ± mevcut: $kullaniciAdi');

        final guncelKullanici = existingUser.copyWith(
          ad: userInfo['ad'] ?? existingUser.ad,
          soyad: userInfo['soyad'] ?? existingUser.soyad,
          profilFotografi:
              userInfo['profil_fotografi'] ?? existingUser.profilFotografi,
          guncellemeTarihi: DateTime.now(),
        );

        await _veriTabani.kisiGuncelle(guncelKullanici);
        print('‚úÖ Kullanƒ±cƒ± bilgileri g√ºncellendi: $kullaniciAdi');

        await _registerDevice(kullaniciAdi, userInfo);
      }
    } catch (e) {
      print('‚ùå Kullanƒ±cƒ± kontrol/kayƒ±t hatasƒ±: $e');
    }
  }

  /// Cihaz bilgilerini kaydet (√ßoklu cihaz desteƒüi i√ßin)
  Future<void> _registerDevice(
    String kullaniciAdi,
    Map<String, dynamic> userInfo,
  ) async {
    try {
      final deviceId = 'mobile_${DateTime.now().millisecondsSinceEpoch}';
      final deviceName = userInfo['device_name'] ?? 'Bilinmeyen Cihaz';
      final platform = userInfo['platform'] ?? 'unknown';

      print('üì± Cihaz kaydediliyor: $deviceName ($platform)');

      print('‚úÖ Cihaz kaydedildi: $kullaniciAdi -> $deviceName');

      // √áoklu cihaz desteƒüi i√ßin cihaz bilgilerini sakla
      _bagliCihazlar.add({
        'device_id': deviceId,
        'kullanici_adi': kullaniciAdi,
        'device_name': deviceName,
        'platform': platform,
        'connection_time': DateTime.now().toIso8601String(),
        'last_seen': DateTime.now().toIso8601String(),
        'connection_type': 'qr_login',
      });
    } catch (e) {
      print('‚ùå Cihaz kayƒ±t hatasƒ±: $e');
    }
  }
}
